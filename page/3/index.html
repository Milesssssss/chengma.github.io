<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>马达的笔记</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">马达的笔记</h1><a id="logo" href="/.">马达的笔记</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h2 class="post-title"><a href="/2016/06/21/精通CSS与HTML设计模式/">精通CSS与HTML设计模式</a></h2><div class="post-meta">2016-06-21</div><div class="post-content"><h2 id="2014-12-22"><a href="#2014-12-22" class="headerlink" title="2014-12-22"></a>2014-12-22</h2><h3 id="第一章：轻松搞定CSS"><a href="#第一章：轻松搞定CSS" class="headerlink" title="第一章：轻松搞定CSS"></a>第一章：轻松搞定CSS</h3><ul><li><p>设计模式–精心组织的解决方案</p><ul><li>常用功能的组合</li><li>模式的名字，要解决的问题，解决方案和各方面的权衡。</li></ul></li></ul><ul><li><h4 id="1-2-使用设计模式"><a href="#1-2-使用设计模式" class="headerlink" title="1.2 使用设计模式"></a>1.2 使用设计模式</h4><ul><li>通过把45种常见的CSs属性与4种元素（内联，内联块状，块状和表格）和5种定位方法（静态，相对，绝对，固定，浮动）结合创建。</li><li>强大威力：很容易利用基础的模式并将它们组合来构造出更加复杂的模式。</li><li>background：CSS内建的设计模式。</li><li>绝对定位(absolute)：相对另外一个元素从新定位。</li><li>文本替换（Text Replacement）：文本藏在图片的后面。这样一来，图片下载失败，可以显示文字。</li><li>左外边距（Left Marginal）：个或多个元素移出块状元素。可以使标题放在左边，内容放在右边。</li><li>外边距图片字母下沉（Marginal Graphic Dropcap）：块状元素的左边距里创建一个图形化的首字母下沉，集文本替换和左外边距模式之大成。</li></ul></li></ul><ul><li><h4 id="1-3-引用样式表"><a href="#1-3-引用样式表" class="headerlink" title="1.3 引用样式表"></a>1.3 引用样式表</h4><ul><li>在<code>head</code>区域使用<code>link</code>元素的<code>href</code>属性。</li></ul></li></ul><ul><li><h4 id="1-4-CSS语法"><a href="#1-4-CSS语法" class="headerlink" title="1.4 CSS语法"></a>1.4 CSS语法</h4><ul><li>CSS代码应当小写（属性和值不区分大小写）。</li><li>常量值不用引号</li><li>分号用来终止CSS规则和Import语句。</li><li>CSS注释 <code>/* CSS */</code></li></ul></li></ul><ul><li><h4 id="1-5-使用层叠排序"><a href="#1-5-使用层叠排序" class="headerlink" title="1.5 使用层叠排序"></a>1.5 使用层叠排序</h4><ul><li>规则划分为6组(高优先级会覆盖低优先级规则 高-&gt;低)<ul><li>1.使用 <code>！important</code> 规则群组拥有最高优先级。</li><li>2.第二优先级：嵌套在 <code>style</code> 中的样式。由于不便于维护，不建议使用。</li><li>3.拥有一个或多个 <code>id</code> 选选择符的规则。</li><li>4.拥有一个或多个类，属性，或伪类选择符的规则。</li><li>5.拥有一个或多个元素选择符的规则。</li><li>6.统配选择符。 e.g. <code>*{border:opx}</code></li></ul></li><li>位于同一选择符群组并且拥有同样的等级和数量。优先级会按照位置来排。6种位置群组排列顺序（高-&gt;低）<ul><li>1.在HTML文档头部中的 <code>&lt;style&gt;</code> 元素。会覆盖@import导入的属性。</li><li>2.<code>&lt;style&gt;</code> 元素中<code>@import</code> 引入的规则要高于 <code>link</code> 引入的规则。</li><li>3.通过 <code>link</code> 元素链接的样式表。</li><li>4.通过 <code>link</code> 链接的样式表中通过 <code>@import</code> 语句引入的样式表。</li><li>5.终端用户绑定的样式表。</li><li>6.浏览器所提供的默认样式表。</li></ul></li></ul></li></ul><ul><li><h4 id="1-6-简化层叠"><a href="#1-6-简化层叠" class="headerlink" title="1.6 简化层叠"></a>1.6 简化层叠</h4><ul><li>为了保持叠层尽可能简单，把绑定的样式最小化，但是不使用 <code>@import</code> 语句。</li><li>避免使用 <code>!important</code>。</li><li>对每个选择符进行排序。<ul><li>层叠顺序</li><li><code>通配选择符</code></li><li><code>元素选择符</code></li><li><code>类，属性和伪类选择符</code></li><li><code>ID选择符</code></li><li><code>！important 通赔选择符</code></li><li><code>!important 元素选择符</code></li><li><code>!important 类，属性和伪类选择符</code></li><li><code>！important ID选择符</code></li></ul></li></ul></li></ul><ul><li><h4 id="1-14-变量的度量单位"><a href="#1-14-变量的度量单位" class="headerlink" title="1.14 变量的度量单位"></a>1.14 变量的度量单位</h4><ul><li><code>em</code>：赋值给元素的font-size。在font-size这种情况下，是赋值给它的父类。例如，5em是指5倍的font-size。要把元素相对其文本来设置时，是文档布局依据你的文本大小而伸缩。</li><li><code>ex</code>：指元素的当前字体中字母x的高度，与em是相关的，很少使用它。</li></ul></li></ul><ul><li><h4 id="1-15-固定的度量单位"><a href="#1-15-固定的度量单位" class="headerlink" title="1.15 固定的度量单位"></a>1.15 固定的度量单位</h4><ul><li><code>in</code>：逻辑上的英尺。</li><li><code>px</code>：像素。对图片定位时很有用，图片是以像素为单位度量的。</li><li><code>pt</code>：点。1/72 in</li><li><code>pc</code>：指派卡。</li><li><code>cm</code>：逻辑厘米。</li><li><code>mm</code>：毫米。</li></ul></li><li><h4 id="1-19-使样式表规范化"><a href="#1-19-使样式表规范化" class="headerlink" title="1.19 使样式表规范化"></a>1.19 使样式表规范化</h4><ul><li>载入你的页面将有多块。<ul><li>寻找你的文件 延时0.1-0.5秒。宽带连接阶段。</li><li>为了提高性能，浏览器把文件放在缓存里。</li><li>当缓存的文件到期了，浏览器会询问那个服务器文件是否更改。</li><li>文件没有到期，即使文件做了修改，浏览器也不会跟新。</li></ul></li></ul></li></ul><h2 id="2014-12-23"><a href="#2014-12-23" class="headerlink" title="2014-12-23"></a>2014-12-23</h2><h3 id="第二章：HTML设计模式"><a href="#第二章：HTML设计模式" class="headerlink" title="第二章：HTML设计模式"></a>第二章：HTML设计模式</h3><pre><code>- 如何结构化和语义化的使用元素。</div><p class="readmore"><a href="/2016/06/21/精通CSS与HTML设计模式/">阅读更多</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/06/21/post/">post</a></h2><div class="post-meta">2016-06-21</div><p class="readmore"><a href="/2016/06/21/post/">阅读更多</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/06/21/process/">process</a></h2><div class="post-meta">2016-06-21</div><div class="post-content"><h3 id="process-对象"><a href="#process-对象" class="headerlink" title="process 对象"></a>process 对象</h3><p><code>process</code> 对象是Node的一个全局对象，提供当前Node进程的信息。<br>它可以在脚本的任意位置使用，不必通过<code>require</code>命令加载。该对象部署了<code>EventEmitter</code>接口。</p><h4 id="进程信息"><a href="#进程信息" class="headerlink" title="进程信息"></a>进程信息</h4><h5 id="退出码"><a href="#退出码" class="headerlink" title="退出码"></a>退出码</h5><p>进程退出时，会返回一个整数值，表示退出时的状态。</p><ul><li>0 正常退出</li><li>1 发生未捕获错误</li><li>5 v8执行错误</li><li>8 不正确的参数</li><li>128+信号值。</li></ul><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>process对象提供一系列属性，用于返回系统信息</p><ul><li>process.argv 返回当前进程的命令行参数数组</li><li>process.env 返回一个对象，成员为当前shell的环境变量。 如<code>process.env.HOME</code></li><li>process.installPrefix node安装路径的前缀</li><li>process.pid 当前进程的进程号</li><li>process.platform 平台 Linux</li><li>process.title 默认值为 node</li><li>process.version Node 的版本</li></ul><h4 id="stdout-stdin-stderr"><a href="#stdout-stdin-stderr" class="headerlink" title="stdout stdin stderr"></a>stdout stdin stderr</h4><h5 id="stdout"><a href="#stdout" class="headerlink" title="stdout"></a>stdout</h5><ol><li>stdout<br>指向标准输出。<br>process.stdout.write(‘message\n’) 等同于console.log</li><li>stdin 标准输入<br>process.stdin.pipe(process.stdout)<br>标准输入导入到标准输出</li><li>stderr 指向标准错误</li></ol><h4 id="argv-execPath-execArgv"><a href="#argv-execPath-execArgv" class="headerlink" title="argv, execPath, execArgv"></a>argv, execPath, execArgv</h4><p><code>argv</code>: 返回一个数组，由命令行脚本时的各个参数组成。<br>第一个成员总是node<br>第二个成员是脚本文件名<br>其余来自脚本文件的参数</p><p><code>execPath</code>: 返回当前执行脚本的Node二进制文件的绝对路径。</p><p><code>execArgv</code>: 返回一个数组，成员在命令行下执行脚本时，在node可执行文件与脚本文件之间的命令行参数。</p><h4 id="process-env"><a href="#process-env" class="headerlink" title="process.env"></a>process.env</h4><p>返回一个对象，包含了当前shell的所有环境变量。</p><h4 id="process-对象提供的方法"><a href="#process-对象提供的方法" class="headerlink" title="process 对象提供的方法"></a>process 对象提供的方法</h4><ul><li>process.chdir() 切换工作目录到指定目录</li><li>process.cwd() 返回当枪脚本的工作目录的路径</li><li>process.exit() 退出当前进程。</li><li>process.getgid() 返回当前进程的组id</li><li>process.getuid() 用户id（数组）</li><li>process.nextTick() 指定回调函数在当前执行栈的尾部，下一次event loop之前执行</li><li>process.on() 监听事件</li><li>process.setgid() 指定当前进程的组</li><li>process.setuid() 指定当前进程的用户</li></ul><h5 id="proess-exit"><a href="#proess-exit" class="headerlink" title="proess.exit()"></a>proess.exit()</h5><p>退出当前进程<br>触发exit 事件</p><h5 id="process-on"><a href="#process-on" class="headerlink" title="process.on()"></a>process.on()</h5><p>监听各种事件，并指定回调函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process.on(&apos;uncaughtException&apos;, function(err)&#123;</span><br><span class="line">   	console.log(&apos;got an error %s&apos;, err.message)</span><br><span class="line">       process.exit(1)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><p>process 支持的事件有以下yixie</p><ul><li>data事件： 数据输出输入时触发</li><li>SIGINT事件： 接收到系统信号时触发</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process.on(&apos;SIGINT&apos;, function()&#123;</span><br><span class="line">   	console.log(&apos;Got a SINGNT.&apos;)</span><br><span class="line">       process.exit(0)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><p>使用时，向该进程发出系统信号，就会导致进程退出<br><code>kill -s SIGINT [process_id]</code></p><p>SIGTERM信号表示内核要求当前进程停止，进程可以自行停止，也可以忽略这个信号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">process.on(&apos;SIGTERM&apos;, function()&#123;</span><br><span class="line">   	server.close(function()&#123;</span><br><span class="line">        process.exit(0)</span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><p>进程不会立马退出，而是执行完回调之后再退出</p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><h5 id="exit事件"><a href="#exit事件" class="headerlink" title="exit事件"></a>exit事件</h5><p>当前进程退出时，触发 exit 事件<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.on(&apos;exit&apos;, function()&#123;</span><br><span class="line">   	fs.writeFileSync(&apos;/tmp/myfile&apos;, &apos;需要保存到硬盘&apos;)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><p></p><p>回调函数只能执行同步操作，不能包含异步操作，因为执行完回调函数之后，进程立马退出。</p><h5 id="beforeExit"><a href="#beforeExit" class="headerlink" title="beforeExit"></a>beforeExit</h5><p>在node清空了eventloop之后，再没有任何任务时，给的最后一次机会，使得node进程不退出。</p><p>主要区别 exit</p><p>可以部署异步操作</p><p>如果未发生捕获错误，或者显式终止程序，则不触发beforeExit</p><h4 id="uncaughtException"><a href="#uncaughtException" class="headerlink" title="uncaughtException"></a>uncaughtException</h4><p>当进程抛出一个未捕获的错误时触发</p><h4 id="信号事件"><a href="#信号事件" class="headerlink" title="信号事件"></a>信号事件</h4></div><p class="readmore"><a href="/2016/06/21/process/">阅读更多</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/06/21/stream/">stream</a></h2><div class="post-meta">2016-06-21</div><div class="post-content"><h3 id="流-stream"><a href="#流-stream" class="headerlink" title="流 stream"></a>流 stream</h3><p>数据还没有接收完成时，就开始处理它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;)</span><br><span class="line">   fs.createReadStream(&apos;path&apos;).pipe(process.stdout)</span><br></pre></td></tr></table></figure><p>以流的方式读取文件，当文件还没有读去完成的情况下就开始输出。<br>对大文件读取非常有利</p><p>读取数据有两种方式：</p><ul><li>同步处理：数据全部读入内存，然后处理</li><li>stream方式：每次读入数据的一小块，每当系统读入一小块数据，就触发一个事件，发出“新数据快”的信号，只要监听这个事件，就能掌握进展，做出相应处理。</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var stream = fs.createReadStream(__dirname + &apos;/data.txt&apos;)</span><br><span class="line">   stream.pipe(res)</span><br></pre></td></tr></table></figure><p><code>Stream</code> 最大的特点：数据会发出node 和 data事件，内置的pipe方法会处理这两个事件。数据流通过pipe方法，可以方便地导向其他具有Stream接口的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.createReadSteam(&apos;wow.txt&apos;)</span><br><span class="line">   	.pipe(zlib.createGzip())</span><br><span class="line">       .pipe(process.stdout)</span><br></pre></td></tr></table></figure><p>打开文本 然后压缩 然后再标准输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.createReadStream(&apos;wow.txt&apos;)</span><br><span class="line">   	.pipe(zlib.createGzip())</span><br><span class="line">       .pipe(fs.createWriteStream(&apos;wow.gz&apos;))</span><br></pre></td></tr></table></figure><p>压缩文件，写入压缩文件</p><h4 id="可读数据流"><a href="#可读数据流" class="headerlink" title="可读数据流"></a>可读数据流</h4><p>用来产生数据。表示数据的来源，只要一个对象提供 可读数据流，就表示你可以从其中读取数据。</p><h4 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h4><p>从系统缓存读取并返回数据。如果读不到数据，返回null</p><p>接受一个整数作为参数，作为返回该数量的数据。<br>如果读不到足够的数量 返回null<br>只有 暂停态时 才有必要手动调用。</p><h4 id="read-1"><a href="#read-1" class="headerlink" title="_read()"></a>_read()</h4><p>将数据放入可读数据流</p><h4 id="setEncoding（）"><a href="#setEncoding（）" class="headerlink" title="setEncoding（）"></a>setEncoding（）</h4><p>utf8</p><h4 id="resume（）"><a href="#resume（）" class="headerlink" title="resume（）"></a>resume（）</h4><p>将可读数据流继续释放 data 事件 转换为流动态</p><h4 id="pause（）"><a href="#pause（）" class="headerlink" title="pause（）"></a>pause（）</h4><p>停止data事件 进入暂停态</p><h4 id="isPaused（）"><a href="#isPaused（）" class="headerlink" title="isPaused（）"></a>isPaused（）</h4><h4 id="pipe（）"><a href="#pipe（）" class="headerlink" title="pipe（）"></a>pipe（）</h4><p>自动传送数据的机制，像管道一样。从可读数据流读出所有的数据，将其写入制定目的地。整个过程是自动的。</p><p>可以链式写法</p><p>第二个参数 <code>{end:false}</code><br>当数据传输结束时，保持打开，必须手动关闭。</p><h4 id="unpipe"><a href="#unpipe" class="headerlink" title="unpipe"></a>unpipe</h4><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><h3 id="可写数据流"><a href="#可写数据流" class="headerlink" title="可写数据流"></a>可写数据流</h3></div><p class="readmore"><a href="/2016/06/21/stream/">阅读更多</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/06/21/npm/">npm</a></h2><div class="post-meta">2016-06-21</div><div class="post-content"><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><h4 id="install"><a href="#install" class="headerlink" title="install"></a>install</h4><p><code>npm install npm@latest -g</code></p><h4 id="npm-init"><a href="#npm-init" class="headerlink" title="npm init"></a>npm init</h4><p><code>npm init -y</code></p><p>跳过提问阶段</p><h4 id="npm-set"><a href="#npm-set" class="headerlink" title="npm set"></a>npm set</h4><p>设置环境变量</p><h4 id="npm-info-packagename"><a href="#npm-info-packagename" class="headerlink" title="npm info packagename"></a>npm info packagename</h4><p>列出模块信息</p><h4 id="npm-search"><a href="#npm-search" class="headerlink" title="npm search"></a>npm search</h4><p>搜索仓库。</p><h4 id="npm-list"><a href="#npm-list" class="headerlink" title="npm list"></a>npm list</h4><h4 id="npm-install"><a href="#npm-install" class="headerlink" title="npm install"></a>npm install</h4><p>安装不同版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install sax@latest</span><br><span class="line">   npm install sax@0.1.1</span><br><span class="line">   npm install sax@&quot;&gt;=0.1.0 &lt;0.2.2&quot;</span><br></pre></td></tr></table></figure><h4 id="避免系统权限"><a href="#避免系统权限" class="headerlink" title="避免系统权限"></a>避免系统权限</h4><p>修改主目录下 .npmrc文件</p><p><code>prefix = /home/yourUsername/npm</code></p><p><code>mkdir ~/npm</code></p><p>在<code>.bash_profile</code><br><code>export PATH=~/npm/bin:$PATH</code></p><h4 id="npm-run"><a href="#npm-run" class="headerlink" title="npm run"></a>npm run</h4><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>使用<code>－－</code> 传参数</p><p><code>npm run test -- 300</code></p><p><code>－s</code>：关闭npm本身的输出，只输出脚本产生的结果。</p><h5 id="scripts-脚本命令的最佳实践"><a href="#scripts-脚本命令的最佳实践" class="headerlink" title="scripts 脚本命令的最佳实践"></a>scripts 脚本命令的最佳实践</h5><p>npm-run-all</p><p>dev</p><p>“dev”:”npm-run-all dev:*”: 用于继发执行所有 dev 的子命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;predev:sass&quot; : &quot;node-sass --source-map src/css/t.scss ./dist/sss.css&quot;</span><br><span class="line"></span><br><span class="line">&quot;dev:autoprefix&quot;: &quot;postcss --use autoprefixer --autoprefixer...&quot;</span><br></pre></td></tr></table></figure><h5 id="serve-脚本命令"><a href="#serve-脚本命令" class="headerlink" title="serve 脚本命令"></a>serve 脚本命令</h5><p>“serve”: “live-server dist/ –port=9090”</p><p>展示指定目录下的 index.html 文件<br>自动刷新功能</p><h5 id="prod-命令"><a href="#prod-命令" class="headerlink" title="prod 命令"></a>prod 命令</h5><p>规定进入生产环境时需要的处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;prod&quot;: &quot;npm-run-all prod:*&quot;,</span><br><span class="line">&quot;prod:sass&quot;: &quot;node-sass --output-style compressed src/sass/base.scss src/css/prod/hoodie.min.css&quot;,</span><br><span class="line">&quot;prod:autoprefix&quot;: &quot;postcss --use autoprefixer --autoprefixer.browsers &quot;&gt; 5%&quot; --output src/css/prod/hoodie.min.css src/css/prod/hoodie.min.css&quot;</span><br></pre></td></tr></table></figure><h5 id="help"><a href="#help" class="headerlink" title="help"></a>help</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;help&quot;: &quot;markdown-chalk --input DEVELOPMENT.md&quot;</span><br></pre></td></tr></table></figure><p>markdown</p><h5 id="docs"><a href="#docs" class="headerlink" title="docs"></a>docs</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;docs&quot;: &quot;kss-node --source src/sass --homepage ../../styleguide.md&quot;</span><br></pre></td></tr></table></figure><p>kss－node 提供源码的注释生成markdown格式的文档</p><h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h5><ul><li>＊ 匹配0个或多个字符</li><li>？ 匹配1个字符</li><li>[…] 匹配某个范围的字符。如果该范围的第一个字符是<code>！</code>或者是 <code>^</code>, 则匹配不在该范围的字符</li><li>!(pattern|pattern|pattern) 匹配任何不符合给定的模式</li><li>?(pattern|pattern|pattern) 匹配0个或1个给定的模式</li><li>+(pattern|pattern|pattern) 匹配1个或多个给定的模式</li><li>*(a|b|c) 匹配0个或多个给定的模式</li><li>@(pattern|pat*|pat?erN) 只匹配给定模式之一！！！</li><li>** 如果出现路径部分，表示0个或多个子目录</li></ul></div><p class="readmore"><a href="/2016/06/21/npm/">阅读更多</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/06/21/packageJson/">Package.json</a></h2><div class="post-meta">2016-06-21</div><div class="post-content"><h3 id="Package-json"><a href="#Package-json" class="headerlink" title="Package.json"></a>Package.json</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>定义项目所需要的各种模块，以及项目的配置信息。</p><h4 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h4><p><code>npm run start</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">   	&quot;start&quot; : &quot;node index.js&quot;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="dependencies-devDependencies-peerDenpendencies"><a href="#dependencies-devDependencies-peerDenpendencies" class="headerlink" title="dependencies, devDependencies, peerDenpendencies"></a>dependencies, devDependencies, peerDenpendencies</h4><ul><li>dependencies: 项目运行所依赖的模块</li><li><p>devDenpendencies：项目开发所需要的模块</p></li><li><p>peerDependencies: 主要用来供插件指定其所需要的主软件的版本。</p></li></ul><h4 id="config-字段"><a href="#config-字段" class="headerlink" title="config 字段"></a>config 字段</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   	&quot;name&quot;: &quot;foo&quot;,</span><br><span class="line">       &quot;config&quot;: &#123;&quot;port&quot;: &quot;8080&quot;&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在程序中可以 process.env.npm_package_config_port 访问</p><p><code>npm config set foo:port 80</code></p></div><p class="readmore"><a href="/2016/06/21/packageJson/">阅读更多</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/06/21/CommonJS/">CommonJS</a></h2><div class="post-meta">2016-06-21</div><div class="post-content"><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>特点：</p><ul><li>所有代码都运行在模块作用域，不会污染全局作用域</li><li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果被缓存，以后再加载读取缓存结果。要想再次运行，必须清除缓存。</li><li>模块加载的顺序，按照其在代码中出现的顺序</li></ul><h4 id="module对象"><a href="#module对象" class="headerlink" title="module对象"></a>module对象</h4><p>Node内部提供了一个 <code>Module</code> 对象。所有模块都是 <code>Module</code> 的实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Module(id, parent)&#123;</span><br><span class="line">   	this.id = id</span><br><span class="line">       this.exports = &#123;&#125;</span><br><span class="line">   	this.parent = parent</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>每个模块内部，都有一个 <code>module</code> 对象，代表当前模块。具有以下属性：</p><ul><li>module.id 模块的识别符，通常带有绝对路径的模块文件名</li><li>module.filename 模块的文件名，带有绝对路径。</li><li>module.loaded 返回一个布尔值，表示模块时否已经完成加载</li><li>module.parent 返回一个对象，表示调用该模块的模块</li><li>module.children 返回一个数组，表示该模块要用到的其它模块</li><li>module.exports 表示模块对外输出的值。</li></ul><h4 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h4><p>为了方便，node为每个模块提供了一个exports变量，指向module.exports.</p><p>Note：不能直接将 <code>export</code> 变量指向一个值，因为这样等于切断了<code>exports</code> 与 <code>module.exports</code> 的联系</p><p>如果是一个单一的值，直接用 <code>module.exports = value</code></p><h4 id="require"><a href="#require" class="headerlink" title="require"></a>require</h4><h5 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h5><p>读入并执行一个 javascript 文件， 然后返回该模块的 exports 对象。如果没有指定模块，则报错</p><p>如果模块输出的是一个函数，那就不能定义在exports对象上，而要定义在 module 上面</p><h5 id="目录加载规则"><a href="#目录加载规则" class="headerlink" title="目录加载规则"></a>目录加载规则</h5><p>通常，会把相关的文件放在一个目录里面，便于组织。这时，最好为该目录设置一个入口文件。让 require 方法可以通过这个入口文件，加载整个目录。</p><p>在package。json 文件中，加入一个 main 字段。 自动加载main 路径入口文件。</p><h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><p><code>delete require.cache[moduleName]</code></p><h5 id="环境变量-NODE-PATH"><a href="#环境变量-NODE-PATH" class="headerlink" title="环境变量 NODE_PATH"></a>环境变量 NODE_PATH</h5><p>Node执行的时候，会先查看环境变量 NODE_PATH. 它是一组以冒号分隔的绝对路径。在其它位置找不到指定模块时，Node会去这些路径查找。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export NODE_PATH=&quot;/usr/local/lib/node&quot;</span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2016/06/21/CommonJS/">阅读更多</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/06/21/node 命令行程序开发/">node 命令行程序开发</a></h2><div class="post-meta">2016-06-21</div><div class="post-content"><p>[TOC]</p><h2 id="node-命令行程序开发"><a href="#node-命令行程序开发" class="headerlink" title="node 命令行程序开发"></a>node 命令行程序开发</h2><h3 id="可执行脚本"><a href="#可执行脚本" class="headerlink" title="可执行脚本"></a>可执行脚本</h3><p>将执行文件写入 <code>package.json</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;name&quot;: &quot;hello&quot;,</span><br><span class="line">    &quot;bin&quot;: &#123;</span><br><span class="line">    	&quot;hello&quot;: &quot;hello&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行 <code>npm link</code>命令</p><p>然后再执行hello，就不用再单独输入路径。</p><h3 id="命令行参数原始写法"><a href="#命令行参数原始写法" class="headerlink" title="命令行参数原始写法"></a>命令行参数原始写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;hello&apos;, process.argv[2])</span><br></pre></td></tr></table></figure><p>process.argv 第一个参数默认是 node<br>第二个参数是执行路径<br>第三个开始是用户输入部分。</p><h3 id="通过child-process-模块新建子进程，从而执行unix系统命令"><a href="#通过child-process-模块新建子进程，从而执行unix系统命令" class="headerlink" title="通过child_process 模块新建子进程，从而执行unix系统命令"></a>通过child_process 模块新建子进程，从而执行unix系统命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var name = process.argv[2]</span><br><span class="line">var exec = require(&apos;child_process&apos;).exec</span><br><span class="line"></span><br><span class="line">var child = exec(&apos;echo hello&apos;, function(err, stdout, stderr)&#123;</span><br><span class="line">	if(err) throw err</span><br><span class="line">    console.log(stdout)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="shelljs-模块"><a href="#shelljs-模块" class="headerlink" title="shelljs 模块"></a>shelljs 模块</h3><p>shelljs 模块包装了 child_process, 使得调用系统进程更加方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save shelljs</span><br></pre></td></tr></table></figure><p>本地模式<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var name = process.argv[2]</span><br><span class="line">var shell = require(&apos;shelljs&apos;)</span><br><span class="line">shell.exec(&apos;echo hello&apos;)</span><br></pre></td></tr></table></figure><p></p><p>全局模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;shelljs/global&apos;)</span><br><span class="line"></span><br><span class="line">cd(&apos;lib&apos;)</span><br><span class="line">ls(&apos;*.js&apos;).forEach(function(file)&#123;</span><br><span class="line">	console.log(file)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">cd(&apos;..&apos;)</span><br></pre></td></tr></table></figure><h3 id="yargs-模块"><a href="#yargs-模块" class="headerlink" title="yargs 模块"></a>yargs 模块</h3><p>解决如何处理命令行参数的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save yargs</span><br></pre></td></tr></table></figure><p>yargs 提供 argv 对象，用来读取命令行参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var argv = require(&apos;yargs&apos;).argv</span><br><span class="line"></span><br><span class="line">console.log(&apos;hello&apos;, argv.name)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hello --name=tom</span><br><span class="line">hello tom</span><br></pre></td></tr></table></figure><p>可以使用<code>alias</code>方法，指定name是n的别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var argv = require(&apos;yargs&apos;)</span><br><span class="line">	.alias(&apos;n&apos;, &apos;name&apos;)</span><br><span class="line">    .argv</span><br><span class="line">console.log(&apos;hello&apos;, argv.n)</span><br></pre></td></tr></table></figure><p>这样短参数和长参数就都可以使用了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$hello -n tom</span><br><span class="line">$hello --name tom</span><br></pre></td></tr></table></figure><p><code>argv</code>对象有一个下划线（_）属性，可以获取非连接词线开头的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var argv = require(&apos;yargs&apos;).argv</span><br><span class="line"></span><br><span class="line">console.log(&apos;hello&apos;, argv.n)</span><br><span class="line">console.log(argv._)</span><br></pre></td></tr></table></figure><p>用法<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hello A -n tom B C</span><br><span class="line">hello tom</span><br><span class="line">[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]</span><br></pre></td></tr></table></figure><p></p><h3 id="命令行参数的配置"><a href="#命令行参数的配置" class="headerlink" title="命令行参数的配置"></a>命令行参数的配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">demand： 是否必选</span><br><span class="line">default： 默认值</span><br><span class="line">describe： 提示</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var argv = require(&apos;yargs&apos;)</span><br><span class="line">	.demand([&apos;n&apos;])</span><br><span class="line">    .default(&#123;n: &apos;tom&apos;&#125;)</span><br><span class="line">    .describe(&#123;n: &apos;your name&apos;&#125;)</span><br><span class="line">    .argv</span><br><span class="line"></span><br><span class="line">console.log(&apos;hello&apos;, argv.n)</span><br></pre></td></tr></table></figure><p>指定n不可忽略，默认值为tom，并给出一行提示。</p><p>options 方法允许将所有这些配置写进一个对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var argv = require(&apos;yargs&apos;)</span><br><span class="line">	.option(&apos;n&apos;, &#123;</span><br><span class="line">    	alias: &apos;name&apos;,</span><br><span class="line">        demand: true,</span><br><span class="line">        default: &apos;tom&apos;,</span><br><span class="line">        describe: &apos;your name&apos;,</span><br><span class="line">        type: &apos;string&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">    .argv</span><br><span class="line">console.log(&apos;hello &apos;, argv.n)</span><br></pre></td></tr></table></figure><p>boolean 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var argv = require(&apos;yargs&apos;)</span><br><span class="line">	.boolean(&apos;[n]&apos;)</span><br><span class="line">    .argv</span><br><span class="line">console.log(&apos;hello &apos;, argv.n)</span><br></pre></td></tr></table></figure><h3 id="帮助信息"><a href="#帮助信息" class="headerlink" title="帮助信息"></a>帮助信息</h3><p>1.usage: 用法格式<br>2.example： 提供例子<br>3.help： 显示帮助信息<br>4.epilog： 出现在帮助信息的结尾</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var argv = require(&apos;yargs&apos;)</span><br><span class="line">	.option(&apos;f&apos;, &#123;</span><br><span class="line">    	alias: &apos;name&apos;,</span><br><span class="line">        demand: true,</span><br><span class="line">        default: &apos;tom&apos;,</span><br><span class="line">        describe: &apos;your name&apos;,</span><br><span class="line">        type: &apos;string&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">    .usage(&apos;Usage: hello [options]&apos;)</span><br><span class="line">    .example(&apos;hello -n tom&apos;, &apos;say hello to Tom&apos;)</span><br><span class="line">    .help(&apos;h&apos;)</span><br><span class="line">    .alias(&apos;n&apos;, &apos;help&apos;)</span><br><span class="line">    .epilog(&apos;copyright 2015&apos;)</span><br><span class="line">    .argv</span><br><span class="line"></span><br><span class="line">console.log(&apos;hello&apos;, argv.n)</span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2016/06/21/node 命令行程序开发/">阅读更多</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/06/21/Events/">cEvents</a></h2><div class="post-meta">2016-06-21</div><div class="post-content"><h3 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>一个对象可以通过这个模块，向另一个对象传递消息</p><p>任意对象都可以发布指定事件，被<code>EventEmitter</code>实例的 <code>on</code> 方法监听到。</p></div><p class="readmore"><a href="/2016/06/21/Events/">阅读更多</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/06/21/html5 Canvas/">HTML5 Canvas核心技术 图形，动画与游戏开发</a></h2><div class="post-meta">2016-06-21</div><div class="post-content"><h2 id="HTML5-Canvas核心技术-图形，动画与游戏开发"><a href="#HTML5-Canvas核心技术-图形，动画与游戏开发" class="headerlink" title="HTML5 Canvas核心技术 图形，动画与游戏开发"></a>HTML5 Canvas核心技术 图形，动画与游戏开发</h2><h3 id="canvas-基础"><a href="#canvas-基础" class="headerlink" title="canvas 基础"></a>canvas 基础</h3><p>Note:</p><ul><li>canvas只有两个属性 width 和 height</li><li>在设置canvas的宽度和高度时，不能使用px后缀</li><li>默认的canvas元素大小是300*150个屏幕像素</li><li>通过width，height属性设置和css设置并不一样。<ul><li>canvas元素实际上有两套尺寸，一个是元素本身的大小，还有一个是元素绘画表面（drawing surface）的大小。</li><li>当设置元素的width和height属性时，实际上是同时修改了该元素本身的大小与绘图表面的大小。</li><li>用css设置只会改变元素的大小。</li><li>设置了css大小，浏览器会对绘图表面进行缩放，使其符合元素的大小。</li></ul></li></ul><h4 id="canvas元素的api"><a href="#canvas元素的api" class="headerlink" title="canvas元素的api"></a>canvas元素的api</h4><ul><li>width：元素与绘图表面宽度，非负整数。</li><li>height：元素与绘图表面高度，非负整数。</li><li>getContext():返回相关的绘图环境对象，</li><li>toDataURL(type, quality):返回一个数据地址，可以将它设定为img元素的src属性值。</li><li>toBlob(callback, type, args…):创建一个用于表示此canvas元素图像文件的blob，</li></ul><h4 id="canvas的绘图环境。"><a href="#canvas的绘图环境。" class="headerlink" title="canvas的绘图环境。"></a>canvas的绘图环境。</h4><p>仅仅是为了充当绘图环境对象的容器而存在的，该环境对象提供了全部的绘图功能，</p><h5 id="2d绘图环境"><a href="#2d绘图环境" class="headerlink" title="2d绘图环境"></a>2d绘图环境</h5><p>CanvasRenderingContext2D对象所含的属性</p><ul><li>canvas： 绘图环境的canvas对象，通常用来获取canvas的高度与宽度</li><li>fillstyle：指定绘图环境后续图形填充操作中所使用的颜色，渐变色或图案。</li><li>font：字符</li><li>globalAlpha：全局透明度设定。将每个像素的alpha值与该值相乘。</li><li>globalCompsiteOperation：将某个物体绘制在其他物体之上时，所采用的绘制方式。</li><li>lineCap:告诉浏览器如何绘制段落的端点。</li><li>lineWidth：绘制线段的屏幕像素宽度。</li><li>lineJoin：如何绘制焦点，可取值：bevel，round，miter（默认值）。</li><li>miterLimit：miter形式的段落焦点</li><li>shadowBlur：如何延伸阴影效果。</li><li>shadowColor：阴影颜色。</li><li>shadowOffsetX:</li><li>shadowOffseY:</li><li>strokeStyle:描边</li><li>textAlign</li><li>textBaseline:垂直对其方式。</li></ul><h5 id="3d绘画环境的webGL简介"><a href="#3d绘画环境的webGL简介" class="headerlink" title="3d绘画环境的webGL简介"></a>3d绘画环境的webGL简介</h5><p>与2d对应的3d绘画环境，叫做webGL。</p><h5 id="canvas状态的保存与恢复"><a href="#canvas状态的保存与恢复" class="headerlink" title="canvas状态的保存与恢复"></a>canvas状态的保存与恢复</h5><ul><li>save()：将当前canvas的状态推送到一个保存canvas状态的堆栈顶部。</li><li>restore()：将canvas状态堆栈顶部的条目弹出，原来保存于栈顶的那一组状态，在弹出之后，就被设置成canvas当前的状态了。</li></ul><p>长久以来，开发者一直使用 <code>setInterval</code> 或者 <code>setTimeout</code> 方法来绘制基于网络的动画。<br>这些方法并不适用于对性能要求很高的动画，应该使用 requestAnimationFrame()方法来取代他们。</p><h5 id="控制台与调试器"><a href="#控制台与调试器" class="headerlink" title="控制台与调试器"></a>控制台与调试器</h5><ul><li>性能分析器（profile）：</li><li>时间轴工具（Timeline）：</li><li>jsPerf：js性能分析网站</li></ul><h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h4><h5 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">canvas.onmousedown = function(e)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addEventListener()<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">canvas.addEventListener(&apos;mousedown&apos;, function(e)&#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>将鼠标坐标转换为canvas坐标<br>开发者需要知道发生鼠标事件的点相对于canvas的位置，而不是整个窗口中的位置，所以必须进行坐标转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function windowToCanvas(canvas, x, y)&#123;</span><br><span class="line">	var bbox = canvas.getBoundingClientRect();</span><br><span class="line">    return &#123;</span><br><span class="line">    	x:x-bbox.left*(canvas.width/bbox.width),</span><br><span class="line">        y:y-bbox.top*(canvas.height/bbox.height)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h5><p>canvas 是一个不可获取焦点的元素，在document或window对象上监听事件。</p><h5 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h5><h4 id="绘制表面的保存与恢复"><a href="#绘制表面的保存与恢复" class="headerlink" title="绘制表面的保存与恢复"></a>绘制表面的保存与恢复</h4><p>使用getImageData（） 与 putImageData() 操作图像<br>立即模式（imediate-mode）绘制图形。不会包含将要绘制的图形对象列表。</p><p>example: getImageData() 与 putImageData()实现拖动图形</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var canvas = document.getElementById(&apos;canvas&apos;);</span><br><span class="line">var contexst = canvas.getContext(&apos;2d&apos;);</span><br><span class="line"></span><br><span class="line">function saveDrawingSurface()&#123;</span><br><span class="line">	drawingSurfaceImageData = context.getImageData(0, 0, cavas.width, canvas.height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function restoreDrawingSurface()&#123;</span><br><span class="line">	context.putImageData(drawingSurfaceImageData, 0, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">canvas.onmousedown = function(e)&#123;</span><br><span class="line">	saveDrawingSurface();</span><br><span class="line">&#125;</span><br><span class="line">canvas.onmousemove = function(e)&#123;</span><br><span class="line">	var loc = windowToCanvas(e);</span><br><span class="line">    if (dragging)&#123;</span><br><span class="line">    	restoreDrawingSurface();</span><br><span class="line">        </span><br><span class="line">        if(guidewires)&#123;</span><br><span class="line">        	drawGuidewires(mousedown.x, mousedown.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">canvas.mouseup = function(e)&#123;</span><br><span class="line">	restoreDrawingSurface();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在canvas中使用html元素"><a href="#在canvas中使用html元素" class="headerlink" title="在canvas中使用html元素"></a>在canvas中使用html元素</h4><p>为了让html控件看上去好像是出现在canvas范围内，可以使用css将这些控件放置在canvas之上。</p><h4 id="不可见的html元素"><a href="#不可见的html元素" class="headerlink" title="不可见的html元素"></a>不可见的html元素</h4><p>在用户拖动鼠标时动态地修改div元素的大小。</p><h5 id="离屏canvas"><a href="#离屏canvas" class="headerlink" title="离屏canvas"></a>离屏canvas</h5><p>把背景存储在一个或多个离屏canvas之中，并将这些离屏canvas中的某一部分复制到屏幕上，以此大幅提高应用程序的性能。</p><h5 id="基础数学知识简介"><a href="#基础数学知识简介" class="headerlink" title="基础数学知识简介"></a>基础数学知识简介</h5><ul><li>求解代数方程</li><li>三角函数</li><li>正弦，余弦与正切函数</li><li>向量运算</li><li></li></ul><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><h4 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h4><p>坐标系统的变换是canvas之中一项非常基本的功能。</p><h4 id="canvas的绘制模型"><a href="#canvas的绘制模型" class="headerlink" title="canvas的绘制模型"></a>canvas的绘制模型</h4><p>在canvas上绘制图形或图像时，浏览器要按照如下步骤来操作：</p><ul><li>将图形或图像绘制到一个无限大的透明位图中，在绘制时遵从当前的填充模式、描边模式以及线条样式。</li><li>将图形或图像的阴影绘制到另外一副位图中，在绘制时使用当前绘制环境的阴影设定。</li><li>将阴影中每一个像素的alpha分量乘以绘图环境对象的globalAlpha属性值。</li><li>将绘有阴影的位图与经过剪辑区域剪切过的canvas进行图像合成，在操作时使用当前合成模式参数。</li><li>将图形或图像的每一个像素颜色分量，乘以绘图环境对象的globalAlpha属性值。</li><li>将绘有图形或图像的位图，合成到当前经过剪辑区域剪切过的canvas位图之上，在操作时使用当前的合成操作符。</li></ul><h4 id="矩形的绘制"><a href="#矩形的绘制" class="headerlink" title="矩形的绘制"></a>矩形的绘制</h4><p>canvas的api提供了如下三个方法，分别用于矩形的消除，描边及填充：</p><ul><li><p>clearRect(double x, double y, double w, double h)</p><ul><li>所谓清除像素，指的是将其颜色设置成为全透明的黑色。</li></ul></li><li><p>strokeRect(double x, double y, double w, double h)</p><ul><li>如果宽度或者高度有一个为0 将分别绘制一条竖线或横线，如果都为0，着不绘制任何东西。</li></ul></li><li>fillRect(double x, double y, double w, double h)</li></ul><h4 id="颜色与透明度"><a href="#颜色与透明度" class="headerlink" title="颜色与透明度"></a>颜色与透明度</h4><p>strokeStyle 与 fillstyle 的属性值可以是任意有效的css颜色字串。rgb，rgba，hsl，hsla</p><p>note：rgb方式有两个缺陷：</p><ul><li>以硬件为导向。基于“阴极射线管”。（显像管）</li><li>不直观。</li></ul><p>globalAlpha:默认值1.0 全局透明度</p><h4 id="渐变色与图案"><a href="#渐变色与图案" class="headerlink" title="渐变色与图案"></a>渐变色与图案</h4><ul><li>线性渐变色：createLinearGradient() 返回CanvasGradient实例。</li></ul><p>addColorStop() 来向渐变色中增加5个“颜色停止点”</p><ul><li>放射渐变：createRadialGradient()</li></ul><p>example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gradient = context.createRadialGradient(canvas.width/2, canvas.height/2, 10, canvas.width/2, 0, 100);</span><br><span class="line">gradient.addColorStop(0, &apos;blue&apos;);</span><br><span class="line">gradient.addColorStop(.25, &apos;white&apos;);</span><br><span class="line">...</span><br><span class="line">context.fillStyle = gradient;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="图案"><a href="#图案" class="headerlink" title="图案"></a>图案</h5><p>允许使用图案来对图形和文本进行描边与填充。图案：image元素，canvas元素或video元素。<br>createPattern(image, repeat):创建一个可以用来在canvas之中对图形和文本进行描边与填充的图案。</p><h4 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h4><p>通过修改绘图环境中的如下4个属性值来指定阴影效果：</p><ul><li>shadowColor:</li><li>shadowOffsetX:</li><li>shadowOffsetY:</li><li>shandowBlur:</li></ul><p>内嵌阴影：设置shadowOffsetX和shadowOffsetY属性值非0的正整数。<br>可以使用clip()方法显示超出部分的显示。</p><p>Note：阴影肖国栋额绘制可能好耗时：尤其动画效果元素的阴影。</p><h4 id="路径、描边与填充"><a href="#路径、描边与填充" class="headerlink" title="路径、描边与填充"></a>路径、描边与填充</h4><p>绘制图形的方法都是基于路径的（path）。<br>首先调用 <code>beginPath()</code> 方法来开始一段新的路径，rect() 与 arc() 方法分别用于创建矩形及弧形路径。不是封闭的路径，调用 <code>closePath()</code>方法才行。</p><h5 id="路径与子路径"><a href="#路径与子路径" class="headerlink" title="路径与子路径"></a>路径与子路径</h5><p>在某一时刻， canvas之中只能有一条路径存在，canvas规范将其称为“当前路径”。然而，这条路径可以包含许多个子路径（subpath）。</p><p>example:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">context.beginPath();</span><br><span class="line">context.rect(10,10,100,100);</span><br><span class="line">context.stroke();</span><br><span class="line">context.beginPath();</span><br><span class="line">context.rect(50,50,100,100);</span><br><span class="line">context.stroke();</span><br></pre></td></tr></table></figure><p></p><p>Note: 如果不加第二个beginPath 第二次的stroke 将使得当前路径中的两条子路径都被描边，这意味着它会重绘第一个矩形。</p><h5 id="填充路径时使用的“非零环绕规则”"><a href="#填充路径时使用的“非零环绕规则”" class="headerlink" title="填充路径时使用的“非零环绕规则”"></a>填充路径时使用的“非零环绕规则”</h5><p>如果当前路径是循环的，或是包含多个相交的子路径，那么canvas的绘图环境变量就使用“非零环绕规则”。</p><p>非零环绕规则：</p><ol><li>对给定区域画一条足够长的线段，使其线段的终点完全落在路径范围之外。</li><li>将计数器初始化为0， 然后，每当这条线段与路径上的直线或曲线相交时，就改变计数器的值。</li><li>与路径的顺时针部分相交，则+1。</li><li>与路径的逆时针部分相交，则-1。</li><li>如果计数器的最终结果不是0，那么此区域就在路径里面，在调用fill方法是，浏览器就会对其进行填充。</li></ol><h5 id="剪纸效果"><a href="#剪纸效果" class="headerlink" title="剪纸效果"></a>剪纸效果</h5><p>绘制两个园，使用顺时针绘制内部园，逆时针绘制外部圆，对其填色，产生剪纸效果。</p><p>Note：当使用arc方法向当前路径中添加子路径时，该方法必须将上一条子路径的终点与说话圆弧的起点相连。</p><p>arc方法可以控制路径的方向，而rect方法则不行。可以使用path或line代替</p><h4 id="线段"><a href="#线段" class="headerlink" title="线段"></a>线段</h4><p>方法：moveTo 和 lineTo<br>使用stroke方法绘制。</p><h4 id="线段与像素边界"><a href="#线段与像素边界" class="headerlink" title="线段与像素边界"></a>线段与像素边界</h4><ol><li>在某2个像素的边界处绘制一条1像素的线段，那么该线段实际上会占据2个像素的宽度。</li><li>如果在像素边界出绘制一条1像素的垂直线段，那么canvas的绘图环境对象会试着将半个像素在边界中线的右边，将另一半像素绘制在左边。</li></ol><h5 id="网格的绘制。"><a href="#网格的绘制。" class="headerlink" title="网格的绘制。"></a>网格的绘制。</h5><p>Note：</p><h5 id="橡皮筋式选取框"><a href="#橡皮筋式选取框" class="headerlink" title="橡皮筋式选取框"></a>橡皮筋式选取框</h5><p>example：</p><h5 id="虚线的绘制：drawDashedLine-context-context-canvas-width-context-height-20-context-canvas-height-20-14"><a href="#虚线的绘制：drawDashedLine-context-context-canvas-width-context-height-20-context-canvas-height-20-14" class="headerlink" title="虚线的绘制：drawDashedLine(context, context.canvas.width, context.height, 20, context.canvas.height-20, 14);"></a>虚线的绘制：drawDashedLine(context, context.canvas.width, context.height, 20, context.canvas.height-20, 14);</h5><h5 id="通过扩展CanvasRenderingContext2D来绘制虚线"><a href="#通过扩展CanvasRenderingContext2D来绘制虚线" class="headerlink" title="通过扩展CanvasRenderingContext2D来绘制虚线"></a>通过扩展CanvasRenderingContext2D来绘制虚线</h5><h4 id="线段与连接点的绘制"><a href="#线段与连接点的绘制" class="headerlink" title="线段与连接点的绘制"></a>线段与连接点的绘制</h4><p>lineCap 线帽：bevel|miter|round</p><h4 id="圆弧与圆形的绘制"><a href="#圆弧与圆形的绘制" class="headerlink" title="圆弧与圆形的绘制"></a>圆弧与圆形的绘制</h4><p>arc：arc(x, y, radius, startAngle, endAngle, counterClockwise)</p><p>以橡皮筋式辅助线来协助画圆：<br>example：TODO</p><h5 id="arcTo-方法"><a href="#arcTo-方法" class="headerlink" title="arcTo 方法"></a>arcTo 方法</h5><p>arcTo(x1，y1，x2，y2，radius)</p><h4 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h4><ul><li>二次贝塞尔曲线：二次曲线，两个锚点一个控制点。<br><code>quadraticCurveTo(cx, cy, ex, ey)</code> 控制点， 锚点</li><li>三次方贝塞尔曲线：<code>bezierCurveTo(double cpx, double cpy, double cp2x, double cp2y, double x, double y)</code></li></ul><h4 id="多边形的绘制"><a href="#多边形的绘制" class="headerlink" title="多边形的绘制"></a>多边形的绘制</h4><p>moveTo 和 lineTo 的结合</p><p>createPolygonPath 创建多个点的多边形</p><p>example：拖动多边形对象</p><p>编辑贝塞尔曲线：</p><h4 id="自动滚动网页，使其段落路径所对应的元素显示在窗口中"><a href="#自动滚动网页，使其段落路径所对应的元素显示在窗口中" class="headerlink" title="自动滚动网页，使其段落路径所对应的元素显示在窗口中"></a>自动滚动网页，使其段落路径所对应的元素显示在窗口中</h4><p>scrollPathIntoView：</p><h4 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h4><p>对canvas坐标系统进行移动，旋转，缩放等操作。</p><h4 id="坐标系的平移、缩放与旋转"><a href="#坐标系的平移、缩放与旋转" class="headerlink" title="坐标系的平移、缩放与旋转"></a>坐标系的平移、缩放与旋转</h4><p>rotate（double angleInRadians）<br>scale（double x， double y）<br>translate（double x， double y）</p><h5 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">drawArrow(context)</span><br><span class="line">context.translate(canvas.width, 0)</span><br><span class="line">context.scale(-1, 1)</span><br><span class="line">drawArrow(context)</span><br></pre></td></tr></table></figure><h4 id="图像合成"><a href="#图像合成" class="headerlink" title="图像合成"></a>图像合成</h4><p>在canvas中将某个物体绘制在一个物体之上，那么浏览器就会简单的把原物体的图像叠放在目标物体的图像上面。<br>globalCompositeOperation的属性改变默认的图像合成行为。</p><h4 id="剪辑区域"><a href="#剪辑区域" class="headerlink" title="剪辑区域"></a>剪辑区域</h4><p>clip</p><h5 id="通过剪辑区域来擦除图像"><a href="#通过剪辑区域来擦除图像" class="headerlink" title="通过剪辑区域来擦除图像"></a>通过剪辑区域来擦除图像</h5><p><code>clearRect(0,0,canvas.width, canvas.height)</code></p><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><p>文本对象有3个主要方法：</p><ul><li>strokeText(text, x, y)</li><li>fillText(text, x, y)</li><li>measureText(text): 返回一个名为width的属性。表示该文本所占用的宽度。</li></ul><p>canvas文本对象有3个相关属性：</p><ul><li>font</li><li>textAlign</li><li>textBaseline</li></ul><h5 id="子啊圆弧周围绘制文本"><a href="#子啊圆弧周围绘制文本" class="headerlink" title="子啊圆弧周围绘制文本"></a>子啊圆弧周围绘制文本</h5><p>步骤：</p><ul><li>计算圆弧周围每个字符的绘制坐标</li><li>将坐标系平移至绘制字符的地点</li><li>将坐标系旋转PI/2-angle度</li><li>对字符进行描边或填充操作</li></ul><p>Note： 应用程序必须先调用 translate方法后调用rotate方法。</p><h3 id="图像与视频"><a href="#图像与视频" class="headerlink" title="图像与视频"></a>图像与视频</h3><p>canvas的绘图环境提供了4个用于绘图及操作的方法：</p><ul><li>drawImage()</li><li>getImageData()</li><li>putImageData()</li><li>createImageData()</li></ul><p>drawImage 可以将另外一个canvas的内容或者视频的其中一帧绘制到当前canvas之中。</p><h4 id="在canvas中绘制图像"><a href="#在canvas中绘制图像" class="headerlink" title="在canvas中绘制图像"></a>在canvas中绘制图像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var image = new Image()</span><br><span class="line">image.src = &quot;aa&quot;</span><br><span class="line">image.onload = function()&#123;</span><br><span class="line">	context.drawImage(image, 0, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法缺点：必须等待图片加载完成之后才能进行绘制，如果尚未完成加载就进行绘制，会执行失败，而且没有任何提示。</p><p>drawImage 方法：</p><ul><li>drawImage(image, dx, dy)</li><li>drawImage(image, dx, dy, dw, dh)</li><li>drawImage(iamge, sx, sy, sw, sh, dx, dy, dw, dh)</li></ul><p>可以在canvas范围之外绘制图像：图片放大<br>按比例系数，计算图片显示位置</p><h4 id="将一个canvas绘制到另一个canvas之中。"><a href="#将一个canvas绘制到另一个canvas之中。" class="headerlink" title="将一个canvas绘制到另一个canvas之中。"></a>将一个canvas绘制到另一个canvas之中。</h4><p>使用离屏canvas，通常需要遵循4个步骤：</p><ol><li>创建用作离屏canvas的元素。</li><li>设置离屏canvas的高度和宽度。</li><li>在离屏canvas之中进行绘制。</li><li>将离屏canvas的全部或者一部分内容复制到正在显示的canvas之中。</li></ol><p>Note： 离屏canvas会占据一定的内存，不过他们可以显著的提高绘图效率。</p><h3 id="操作图像的像素"><a href="#操作图像的像素" class="headerlink" title="操作图像的像素"></a>操作图像的像素</h3><h4 id="获取图像数据"><a href="#获取图像数据" class="headerlink" title="获取图像数据"></a>获取图像数据</h4><p>getImageData() putImageData()</p><p>ImageData 对象：</p><ul><li>width：设备像素为单位的图像数据宽度。</li><li>height：设备像素为单位的图像数据高度。</li><li>data： 包含各个设备像素数值的数组。</li></ul><p>getImageData():运行的速度比较慢，每次检测到鼠标按下事件的时候，才调用一次getImageData()。</p><p>Note：putImageData()不受全局设置的影响。</p><h4 id="修改图像数据"><a href="#修改图像数据" class="headerlink" title="修改图像数据"></a>修改图像数据</h4><p>ImageData对象中的数组：data属性指向一个包含8位二进制整数的数组，这些整数的值位于0~255之间，分别表示一个像素的红、绿、蓝及透明度分量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(i=3; i&lt;imageData.data.length-4;i += 4 )&#123;</span><br><span class="line">    imageData.data[i] = imageData.data[i] / 2 // Alpha</span><br><span class="line">    imageData.data[i+1] = imageData.data[i+1] // red</span><br><span class="line">    imageData.data[i+2] = imageData.data[i+2] // green</span><br><span class="line">    imageData.data[i+3] = imageData.data[i+3] // blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="图像滤镜"><a href="#图像滤镜" class="headerlink" title="图像滤镜"></a>图像滤镜</h5><p>从255之中减去每个像素的分量值。</p><p>example：浮雕滤镜</p><h5 id="用工作线程处理图像（webworker）"><a href="#用工作线程处理图像（webworker）" class="headerlink" title="用工作线程处理图像（webworker）"></a>用工作线程处理图像（webworker）</h5><p><code>var sunglassFilter = new Worker(&quot;sunglassFilter.js&quot;)</code> 创建一个工作线程。传递给worder构造器的文件名表示工作线程将要执行的javascript文件。</p><p>将耗时的代码放在工作线程中，及时响应用户操作<br>封装算法。</p><h4 id="结合剪辑区域来绘制图像"><a href="#结合剪辑区域来绘制图像" class="headerlink" title="结合剪辑区域来绘制图像"></a>结合剪辑区域来绘制图像</h4><p>图像渐渐淡出：设置alpha值 或者设置globalAlpha</p><p>离屏canvas制作动画：</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>drawImageData 要比putImageData快</p><p>提高效率方法：</p><ol><li>避免在循环体内直接范围对象的属性， 放在局部变量中。</li><li>应该用循环计数器来遍历完整的像素，而非像素分量。</li><li>逆向遍历与移位技巧的效果并不好。</li><li>不要频繁的调用getImageData()来获取数据。</li></ol><h4 id="放大镜"><a href="#放大镜" class="headerlink" title="放大镜"></a>放大镜</h4><p>步骤：</p><ol><li>调用putImageData将上一次背景图像回复到canvas</li><li>调用getImageData捕捉当前位置image</li><li>将剪辑区域设定为放大镜所在范围</li><li>调用drawImage方法，将放大后的图像绘制到canvas中</li><li>绘制放大镜的镜片。</li></ol><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><h4 id="动画循环"><a href="#动画循环" class="headerlink" title="动画循环"></a>动画循环</h4><p>Note：不要使用<code>setInterval</code>或者<code>setTimeOut</code>来做动画。并不能提供制作动画所需要的精确计时机制。它们只是让应用程序能在某个大致时间运行而已。</p><p>不应主动命令浏览器何时去绘制下一帧动画，这应该有浏览器来通知你：使用requerstAnimationFrame</p><h5 id="通过requestAnimationFrame让浏览器自行决定帧速度。"><a href="#通过requestAnimationFrame让浏览器自行决定帧速度。" class="headerlink" title="通过requestAnimationFrame让浏览器自行决定帧速度。"></a>通过requestAnimationFrame让浏览器自行决定帧速度。</h5><p>不使用<code>setInterval</code>和<code>setTimeOut</code>方法原因：</p><ul><li>他们都是通用方法，并不是专门制作动画而用。</li><li>即使向其传递以毫秒为单位的参数值，他们也达不到毫秒级的精确性。</li><li>没有对调用动画循环的机制作优化。</li><li>不考虑绘制动画的最佳时机，而只是一味的以某个大致的时间间隔来调用动画循环。</li></ul><p>返回：传递一个时间值。</p><p>polyfill 多端支持。</p><h4 id="帧速度的计算"><a href="#帧速度的计算" class="headerlink" title="帧速度的计算"></a>帧速度的计算</h4><p>计算：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var lastTime = 0;</span><br><span class="line">function calculateFps()&#123;</span><br><span class="line">    var now = (+new Date),fps = 1000/(now - lastTime);</span><br><span class="line">    lastTime = now;</span><br><span class="line">    return fps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function animate(time)&#123;</span><br><span class="line">    eraseBackground();</span><br><span class="line">    drawBackground();</span><br><span class="line">    update();</span><br><span class="line">    draw();</span><br><span class="line"></span><br><span class="line">    context.fillStyle = &apos;cornflowerblur&apos;;</span><br><span class="line">    context.fillText(calculateFps().toFixed() + &apos; fps&apos; , 20, 60);</span><br><span class="line">    window.requestNextAnimationFrame(animate);</span><br><span class="line">&#125;</span><br><span class="line">window.requestNextAnimationFrame(animate);</span><br></pre></td></tr></table></figure><p></p><h4 id="以不同的帧速率来执行各种任务"><a href="#以不同的帧速率来执行各种任务" class="headerlink" title="以不同的帧速率来执行各种任务"></a>以不同的帧速率来执行各种任务</h4><h4 id="恢复动画背景"><a href="#恢复动画背景" class="headerlink" title="恢复动画背景"></a>恢复动画背景</h4><p>三种办法：</p><ol><li>将内容全部擦除，并重新绘制</li><li>仅重绘内容发生变化的那部分区域</li><li>从离屏缓存区中将内容发生变化的那部分背景图像复制到屏幕上。</li></ol><h5 id="利用剪辑区域来处理动画背景"><a href="#利用剪辑区域来处理动画背景" class="headerlink" title="利用剪辑区域来处理动画背景"></a>利用剪辑区域来处理动画背景</h5><p>如果背景图像很简单，可以全部擦除然后重绘。如果背景复杂，使用离屏</p><ol><li>调用context.save(), 保存canvas状态</li><li>调用beginPath开始新路径</li><li>在context对象上调用arc rect 等方法设置路径</li><li>调用context.clip 剪辑区域</li><li>擦除canvas中的图像</li><li>将背景图像绘制到屏幕canvas中（绘制操作实际上只会影响剪辑区域所在范围）</li><li>恢复canvas的状态参数，该操作主要是为了重置剪辑区域。</li></ol><h5 id="利用图块复制技术来处理动画背景"><a href="#利用图块复制技术来处理动画背景" class="headerlink" title="利用图块复制技术来处理动画背景"></a>利用图块复制技术来处理动画背景</h5><p>将整个背景一次性的复制到离屏canvas中，稍后从离屏canvas中只将修复动画背景所需的那一块图像复制到屏幕中即可。</p><p>优缺点：</p><ul><li>剪辑区域：</li><li>图块复制技术：速度快，但是占据内存</li></ul><h4 id="双缓冲技术"><a href="#双缓冲技术" class="headerlink" title="双缓冲技术"></a>双缓冲技术</h4><p>单缓冲产生闪烁：先讲东西绘制在离屏上 然后一次性的复制到canvas中。<br>双缓冲技术可以有效的消除动画闪烁，浏览器会自动采用双缓冲实现canvas元素。开发者不需要自己实现。</p><p>检测双环从技术：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function animate(now)&#123;</span><br><span class="line">    eraseBackground();</span><br><span class="line">    for(var i=0; i&lt;500000;++i)&#123;</span><br><span class="line">        sum +=i;</span><br><span class="line">    &#125;</span><br><span class="line">    drawBackground()</span><br><span class="line">    draw()</span><br><span class="line">    requestNextAnimationFrame(time)</span><br><span class="line">&#125;</span><br><span class="line">requestNextAnimationFrame(time)</span><br></pre></td></tr></table></figure><h4 id="基于时间的运动"><a href="#基于时间的运动" class="headerlink" title="基于时间的运动"></a>基于时间的运动</h4><p>使动画在所有情况下都以相同速度播放。不受帧速率的影响。<br>根据物体的速度计算出两帧之间所移动的像素数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">像素/帧 = 像素/秒 * 帧/秒</span><br></pre></td></tr></table></figure><p></p><h4 id="背景的滚动"><a href="#背景的滚动" class="headerlink" title="背景的滚动"></a>背景的滚动</h4><p>通过移动canvas绘图环境对象的原点坐标来实现背景滚动效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var SKY_VELOCITY = 30,skyOffset = 0;</span><br><span class="line">   </span><br><span class="line">   function draw()&#123;</span><br><span class="line">   	skyOffset = skyOffset &lt; canvas.width?skyOffset + SKY_VELOCITY:0;</span><br><span class="line">       context.save();</span><br><span class="line">       context.translate(-skyOffset, 0);</span><br><span class="line">       context.drawImage(sky, 0 , 0);</span><br><span class="line">       context.drawImage(sky, sky.width, 0);</span><br><span class="line">       cintext.restore();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>随着绘画环境对象原点的移动，原来位于屏幕外的那副图像渐渐的滚动到屏幕内。</p><h4 id="视差动画"><a href="#视差动画" class="headerlink" title="视差动画"></a>视差动画</h4><p>让动画图层以不同的速冻滚动，这样就实现了视差效果。</p><h4 id="用户手势"><a href="#用户手势" class="headerlink" title="用户手势"></a>用户手势</h4><p>用户通过鼠标或者手指触摸来与动画互动。</p><h4 id="定时动画"><a href="#定时动画" class="headerlink" title="定时动画"></a>定时动画</h4><h5 id="秒表"><a href="#秒表" class="headerlink" title="秒表"></a>秒表</h5><h5 id="动画计时器"><a href="#动画计时器" class="headerlink" title="动画计时器"></a>动画计时器</h5><h4 id="动画制作的最佳指导原则"><a href="#动画制作的最佳指导原则" class="headerlink" title="动画制作的最佳指导原则"></a>动画制作的最佳指导原则</h4><ul><li>使用类似requstNextAnimationFrame() 这样的polyfill 方法来保持浏览器兼容性。</li><li>将业务逻辑的更新与动画的绘制分开</li><li>使用基于时间的运动来协调动画的播放速度</li><li>用剪辑区域或者图块复制技术将复杂的背景图像恢复到屏幕上。</li><li>必要时可使用一个或多个离屏缓冲区提升背景的绘制速度</li><li>不要手工实现传动的双缓冲算法：浏览器会自动实现</li><li>不要通过css指定阴影及圆角效果</li><li>不要在canvas中进行带阴影效果的绘制操作</li><li>不要在播放动画时分配内存</li><li>使用性能调试及时间轴工具来监控并改善动画的绘制效率。</li></ul><h3 id="精灵"><a href="#精灵" class="headerlink" title="精灵"></a>精灵</h3><p>要制作一个精灵对象，必须让开发者能把他们绘制出来，能够将其放置于动画中的制定位置，并且能以给定的速度将其从一个地方移动到另一个地方。这些精灵或许还能接受调用者的命令，来执行某些特定的动作。</p><p>精灵对象有两个方法：paint 和 update<br>构造器：精灵名称，绘制器及行为数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var Sprite = function(name, painter, behaviors)&#123;</span><br><span class="line">    if (name !== undefined) this.name = name;</span><br><span class="line">    if (painter !== undefined) this.painter = painter;</span><br><span class="line">    this.top = 0;</span><br><span class="line">    this.left = 0;</span><br><span class="line">    this.width = 10;</span><br><span class="line">    this.height = 10;</span><br><span class="line">    this.velocityX = 0;</span><br><span class="line">    this.velocityY = 0;</span><br><span class="line">    this.visible = true;</span><br><span class="line">    this.animation = false;</span><br><span class="line">    this.behaviors = behaviors || &#123;&#125;;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sprite.prototype = &#123;</span><br><span class="line">	paint : function(context)&#123;</span><br><span class="line">    	if(this.painter !== undefined &amp;&amp; this.visible)&#123;</span><br><span class="line">        	this.painter.paint(this, context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    update: function(context, time)&#123;</span><br><span class="line">        for(var i=0;i&lt;this.behaviors.length;++i)&#123;</span><br><span class="line">            this.behaviors[i].execute(this, context, time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="精灵绘制器"><a href="#精灵绘制器" class="headerlink" title="精灵绘制器"></a>精灵绘制器</h4><p>Sprite 对象与绘制其内容的绘制器对象之间是解耦的。在程序运行时动态的设定绘制器。<br>Painter对象可被归纳为三类：</p><ul><li>描边及填充绘制器<br>会调用stroke 与 fill 在内的canvas图形函数来绘制精灵。<br>享元模式：使用一个对象表示多个概念</li><li><p>图像绘制器</p></li><li><p>精灵表绘制器<br>为了节省磁盘空间，减少下载次数，如果制作动画的精灵对象其没帧所用的图像都比较小，那么可以把他们放在一张图片中。<br>精灵表会把精灵表中表示当前动画帧的那个单元格画出来。调用advance方法可以将索引值加1.</p></li></ul><h4 id="精灵对象的行为"><a href="#精灵对象的行为" class="headerlink" title="精灵对象的行为"></a>精灵对象的行为</h4><p>只要实现execute(sprite, context, time)方法的对象，都可以叫做 行为。该方法一般会以某种方式来修改精灵的属性，比如移动其位置，或是修改其外观。</p><p>精灵含有一个行为对象数组，它的update方法会遍历该数组，使每个行为对象都得以执行一次。</p><h4 id="将多个行为组合起来"><a href="#将多个行为组合起来" class="headerlink" title="将多个行为组合起来"></a>将多个行为组合起来</h4><p>精灵含有一个行为对象数组，所以开发者可以根据需要向任何精灵对象之中添加任意数量的行为对象。精灵的update方法会从数组中的第一个行为对象开始，一直遍历到最后一个对象，依次调用其execute方法。</p><p>精灵可以有任意多的行为对象，开发者可以在程序运行时直接操作behaviors数组来增加及移除行为对象。</p><h4 id="限时触发的行为"><a href="#限时触发的行为" class="headerlink" title="限时触发的行为"></a>限时触发的行为</h4><p>该对象所封装的行为只会在给定的事件段内表现出来。</p><h4 id="精灵动画制作器"><a href="#精灵动画制作器" class="headerlink" title="精灵动画制作器"></a>精灵动画制作器</h4><h3 id="移动平台开发"><a href="#移动平台开发" class="headerlink" title="移动平台开发"></a>移动平台开发</h3><p>移动设备开发技巧</p><ul><li>通过指定名为<code>viewport</code>的<code>metatag</code> 我们可以根据特定的设备与显示方向优化应用程序的视窗大小。</li><li>css媒体查询</li><li>以javascript语言编写监听器，检测媒体特征的变更。</li><li>处理触摸事件。</li><li>禁用惯性滚动功能。</li><li>禁止用户缩放应用程序，停用“DIV闪烁”等特征</li><li>实现手指缩放功能。</li><li>在平板电脑上实现基于canvas的虚拟键盘控件。</li></ul><p>在ios是那个运行</p><ul><li>创建应用程序图标及启动图像</li><li>使用媒体特征查询技术来选择适当的应用程序图标及启动图像</li><li>令html5应用程序直接以全屏模式运行，不显示任何浏览器饰件</li><li>设置状态栏的背景色</li></ul></div><p class="readmore"><a href="/2016/06/21/html5 Canvas/">阅读更多</a></p></div><nav class="page-navigator"><a class="extend prev" rel="prev" href="/page/2/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">下一页</a></nav></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/DOM/">DOM</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/DOM/html/">html</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/canvas/">canvas</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/css/html/">html</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/html/">html</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/html/css/">css</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/node-js/">node.js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/仓库管理/">仓库管理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端框架/">前端框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/外语/">外语</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/微信/">微信</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/支付/">支付</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/开发工具/" style="font-size: 15px;">开发工具</a> <a href="/tags/DOM/" style="font-size: 15px;">DOM</a> <a href="/tags/node-js/" style="font-size: 15px;">node.js</a> <a href="/tags/Vue/" style="font-size: 15px;">Vue</a> <a href="/tags/MVVM/" style="font-size: 15px;">MVVM</a> <a href="/tags/canvas/" style="font-size: 15px;">canvas</a> <a href="/tags/收集/" style="font-size: 15px;">收集</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/html/" style="font-size: 15px;">html</a> <a href="/tags/仓库管理/" style="font-size: 15px;">仓库管理</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/sql/" style="font-size: 15px;">sql</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/webGL/" style="font-size: 15px;">webGL</a> <a href="/tags/微信/" style="font-size: 15px;">微信</a> <a href="/tags/原型工具/" style="font-size: 15px;">原型工具</a> <a href="/tags/微信支付/" style="font-size: 15px;">微信支付</a> <a href="/tags/事务/" style="font-size: 15px;">事务</a> <a href="/tags/外语/" style="font-size: 15px;">外语</a> <a href="/tags/英语/" style="font-size: 15px;">英语</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/10/14/Vue2/">Vue2</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/13/grid/">CSS Grid</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/26/DOM-Enlightenment-2013-2/">DOM.Enlightenment.2013.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/06/canvas资料收集/">canvas资料收集</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/06/原型工具/">原型工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/22/React-Router/">React Router</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/09/微信接口归纳/">微信接口归纳</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/05/权限系统/">权限系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/03/oAuth/">oAuth</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/02/数据库名词解释/">数据库名词</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">马达的笔记.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>