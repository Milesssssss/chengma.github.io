<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>马达的笔记</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">马达的笔记</h1><a id="logo" href="/.">马达的笔记</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h2 class="post-title"><a href="/2016/06/21/html5 Canvas/">HTML5 Canvas核心技术 图形，动画与游戏开发</a></h2><div class="post-meta">2016-06-21</div><div class="post-content"><h2 id="HTML5-Canvas核心技术-图形，动画与游戏开发"><a href="#HTML5-Canvas核心技术-图形，动画与游戏开发" class="headerlink" title="HTML5 Canvas核心技术 图形，动画与游戏开发"></a>HTML5 Canvas核心技术 图形，动画与游戏开发</h2><h3 id="canvas-基础"><a href="#canvas-基础" class="headerlink" title="canvas 基础"></a>canvas 基础</h3><p>Note:</p><ul><li>canvas只有两个属性 width 和 height</li><li>在设置canvas的宽度和高度时，不能使用px后缀</li><li>默认的canvas元素大小是300*150个屏幕像素</li><li>通过width，height属性设置和css设置并不一样。<ul><li>canvas元素实际上有两套尺寸，一个是元素本身的大小，还有一个是元素绘画表面（drawing surface）的大小。</li><li>当设置元素的width和height属性时，实际上是同时修改了该元素本身的大小与绘图表面的大小。</li><li>用css设置只会改变元素的大小。</li><li>设置了css大小，浏览器会对绘图表面进行缩放，使其符合元素的大小。</li></ul></li></ul><h4 id="canvas元素的api"><a href="#canvas元素的api" class="headerlink" title="canvas元素的api"></a>canvas元素的api</h4><ul><li>width：元素与绘图表面宽度，非负整数。</li><li>height：元素与绘图表面高度，非负整数。</li><li>getContext():返回相关的绘图环境对象，</li><li>toDataURL(type, quality):返回一个数据地址，可以将它设定为img元素的src属性值。</li><li>toBlob(callback, type, args…):创建一个用于表示此canvas元素图像文件的blob，</li></ul><h4 id="canvas的绘图环境。"><a href="#canvas的绘图环境。" class="headerlink" title="canvas的绘图环境。"></a>canvas的绘图环境。</h4><p>仅仅是为了充当绘图环境对象的容器而存在的，该环境对象提供了全部的绘图功能，</p><h5 id="2d绘图环境"><a href="#2d绘图环境" class="headerlink" title="2d绘图环境"></a>2d绘图环境</h5><p>CanvasRenderingContext2D对象所含的属性</p><ul><li>canvas： 绘图环境的canvas对象，通常用来获取canvas的高度与宽度</li><li>fillstyle：指定绘图环境后续图形填充操作中所使用的颜色，渐变色或图案。</li><li>font：字符</li><li>globalAlpha：全局透明度设定。将每个像素的alpha值与该值相乘。</li><li>globalCompsiteOperation：将某个物体绘制在其他物体之上时，所采用的绘制方式。</li><li>lineCap:告诉浏览器如何绘制段落的端点。</li><li>lineWidth：绘制线段的屏幕像素宽度。</li><li>lineJoin：如何绘制焦点，可取值：bevel，round，miter（默认值）。</li><li>miterLimit：miter形式的段落焦点</li><li>shadowBlur：如何延伸阴影效果。</li><li>shadowColor：阴影颜色。</li><li>shadowOffsetX:</li><li>shadowOffseY:</li><li>strokeStyle:描边</li><li>textAlign</li><li>textBaseline:垂直对其方式。</li></ul><h5 id="3d绘画环境的webGL简介"><a href="#3d绘画环境的webGL简介" class="headerlink" title="3d绘画环境的webGL简介"></a>3d绘画环境的webGL简介</h5><p>与2d对应的3d绘画环境，叫做webGL。</p><h5 id="canvas状态的保存与恢复"><a href="#canvas状态的保存与恢复" class="headerlink" title="canvas状态的保存与恢复"></a>canvas状态的保存与恢复</h5><ul><li>save()：将当前canvas的状态推送到一个保存canvas状态的堆栈顶部。</li><li>restore()：将canvas状态堆栈顶部的条目弹出，原来保存于栈顶的那一组状态，在弹出之后，就被设置成canvas当前的状态了。</li></ul><p>长久以来，开发者一直使用 <code>setInterval</code> 或者 <code>setTimeout</code> 方法来绘制基于网络的动画。<br>这些方法并不适用于对性能要求很高的动画，应该使用 requestAnimationFrame()方法来取代他们。</p><h5 id="控制台与调试器"><a href="#控制台与调试器" class="headerlink" title="控制台与调试器"></a>控制台与调试器</h5><ul><li>性能分析器（profile）：</li><li>时间轴工具（Timeline）：</li><li>jsPerf：js性能分析网站</li></ul><h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h4><h5 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">canvas.onmousedown = function(e)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addEventListener()<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">canvas.addEventListener(&apos;mousedown&apos;, function(e)&#123;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>将鼠标坐标转换为canvas坐标<br>开发者需要知道发生鼠标事件的点相对于canvas的位置，而不是整个窗口中的位置，所以必须进行坐标转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function windowToCanvas(canvas, x, y)&#123;</span><br><span class="line">	var bbox = canvas.getBoundingClientRect();</span><br><span class="line">    return &#123;</span><br><span class="line">    	x:x-bbox.left*(canvas.width/bbox.width),</span><br><span class="line">        y:y-bbox.top*(canvas.height/bbox.height)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h5><p>canvas 是一个不可获取焦点的元素，在document或window对象上监听事件。</p><h5 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h5><h4 id="绘制表面的保存与恢复"><a href="#绘制表面的保存与恢复" class="headerlink" title="绘制表面的保存与恢复"></a>绘制表面的保存与恢复</h4><p>使用getImageData（） 与 putImageData() 操作图像<br>立即模式（imediate-mode）绘制图形。不会包含将要绘制的图形对象列表。</p><p>example: getImageData() 与 putImageData()实现拖动图形</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var canvas = document.getElementById(&apos;canvas&apos;);</span><br><span class="line">var contexst = canvas.getContext(&apos;2d&apos;);</span><br><span class="line"></span><br><span class="line">function saveDrawingSurface()&#123;</span><br><span class="line">	drawingSurfaceImageData = context.getImageData(0, 0, cavas.width, canvas.height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function restoreDrawingSurface()&#123;</span><br><span class="line">	context.putImageData(drawingSurfaceImageData, 0, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">canvas.onmousedown = function(e)&#123;</span><br><span class="line">	saveDrawingSurface();</span><br><span class="line">&#125;</span><br><span class="line">canvas.onmousemove = function(e)&#123;</span><br><span class="line">	var loc = windowToCanvas(e);</span><br><span class="line">    if (dragging)&#123;</span><br><span class="line">    	restoreDrawingSurface();</span><br><span class="line">        </span><br><span class="line">        if(guidewires)&#123;</span><br><span class="line">        	drawGuidewires(mousedown.x, mousedown.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">canvas.mouseup = function(e)&#123;</span><br><span class="line">	restoreDrawingSurface();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在canvas中使用html元素"><a href="#在canvas中使用html元素" class="headerlink" title="在canvas中使用html元素"></a>在canvas中使用html元素</h4><p>为了让html控件看上去好像是出现在canvas范围内，可以使用css将这些控件放置在canvas之上。</p><h4 id="不可见的html元素"><a href="#不可见的html元素" class="headerlink" title="不可见的html元素"></a>不可见的html元素</h4><p>在用户拖动鼠标时动态地修改div元素的大小。</p><h5 id="离屏canvas"><a href="#离屏canvas" class="headerlink" title="离屏canvas"></a>离屏canvas</h5><p>把背景存储在一个或多个离屏canvas之中，并将这些离屏canvas中的某一部分复制到屏幕上，以此大幅提高应用程序的性能。</p><h5 id="基础数学知识简介"><a href="#基础数学知识简介" class="headerlink" title="基础数学知识简介"></a>基础数学知识简介</h5><ul><li>求解代数方程</li><li>三角函数</li><li>正弦，余弦与正切函数</li><li>向量运算</li><li></li></ul><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><h4 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h4><p>坐标系统的变换是canvas之中一项非常基本的功能。</p><h4 id="canvas的绘制模型"><a href="#canvas的绘制模型" class="headerlink" title="canvas的绘制模型"></a>canvas的绘制模型</h4><p>在canvas上绘制图形或图像时，浏览器要按照如下步骤来操作：</p><ul><li>将图形或图像绘制到一个无限大的透明位图中，在绘制时遵从当前的填充模式、描边模式以及线条样式。</li><li>将图形或图像的阴影绘制到另外一副位图中，在绘制时使用当前绘制环境的阴影设定。</li><li>将阴影中每一个像素的alpha分量乘以绘图环境对象的globalAlpha属性值。</li><li>将绘有阴影的位图与经过剪辑区域剪切过的canvas进行图像合成，在操作时使用当前合成模式参数。</li><li>将图形或图像的每一个像素颜色分量，乘以绘图环境对象的globalAlpha属性值。</li><li>将绘有图形或图像的位图，合成到当前经过剪辑区域剪切过的canvas位图之上，在操作时使用当前的合成操作符。</li></ul><h4 id="矩形的绘制"><a href="#矩形的绘制" class="headerlink" title="矩形的绘制"></a>矩形的绘制</h4><p>canvas的api提供了如下三个方法，分别用于矩形的消除，描边及填充：</p><ul><li><p>clearRect(double x, double y, double w, double h)</p><ul><li>所谓清除像素，指的是将其颜色设置成为全透明的黑色。</li></ul></li><li><p>strokeRect(double x, double y, double w, double h)</p><ul><li>如果宽度或者高度有一个为0 将分别绘制一条竖线或横线，如果都为0，着不绘制任何东西。</li></ul></li><li>fillRect(double x, double y, double w, double h)</li></ul><h4 id="颜色与透明度"><a href="#颜色与透明度" class="headerlink" title="颜色与透明度"></a>颜色与透明度</h4><p>strokeStyle 与 fillstyle 的属性值可以是任意有效的css颜色字串。rgb，rgba，hsl，hsla</p><p>note：rgb方式有两个缺陷：</p><ul><li>以硬件为导向。基于“阴极射线管”。（显像管）</li><li>不直观。</li></ul><p>globalAlpha:默认值1.0 全局透明度</p><h4 id="渐变色与图案"><a href="#渐变色与图案" class="headerlink" title="渐变色与图案"></a>渐变色与图案</h4><ul><li>线性渐变色：createLinearGradient() 返回CanvasGradient实例。</li></ul><p>addColorStop() 来向渐变色中增加5个“颜色停止点”</p><ul><li>放射渐变：createRadialGradient()</li></ul><p>example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gradient = context.createRadialGradient(canvas.width/2, canvas.height/2, 10, canvas.width/2, 0, 100);</span><br><span class="line">gradient.addColorStop(0, &apos;blue&apos;);</span><br><span class="line">gradient.addColorStop(.25, &apos;white&apos;);</span><br><span class="line">...</span><br><span class="line">context.fillStyle = gradient;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="图案"><a href="#图案" class="headerlink" title="图案"></a>图案</h5><p>允许使用图案来对图形和文本进行描边与填充。图案：image元素，canvas元素或video元素。<br>createPattern(image, repeat):创建一个可以用来在canvas之中对图形和文本进行描边与填充的图案。</p><h4 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h4><p>通过修改绘图环境中的如下4个属性值来指定阴影效果：</p><ul><li>shadowColor:</li><li>shadowOffsetX:</li><li>shadowOffsetY:</li><li>shandowBlur:</li></ul><p>内嵌阴影：设置shadowOffsetX和shadowOffsetY属性值非0的正整数。<br>可以使用clip()方法显示超出部分的显示。</p><p>Note：阴影肖国栋额绘制可能好耗时：尤其动画效果元素的阴影。</p><h4 id="路径、描边与填充"><a href="#路径、描边与填充" class="headerlink" title="路径、描边与填充"></a>路径、描边与填充</h4><p>绘制图形的方法都是基于路径的（path）。<br>首先调用 <code>beginPath()</code> 方法来开始一段新的路径，rect() 与 arc() 方法分别用于创建矩形及弧形路径。不是封闭的路径，调用 <code>closePath()</code>方法才行。</p><h5 id="路径与子路径"><a href="#路径与子路径" class="headerlink" title="路径与子路径"></a>路径与子路径</h5><p>在某一时刻， canvas之中只能有一条路径存在，canvas规范将其称为“当前路径”。然而，这条路径可以包含许多个子路径（subpath）。</p><p>example:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">context.beginPath();</span><br><span class="line">context.rect(10,10,100,100);</span><br><span class="line">context.stroke();</span><br><span class="line">context.beginPath();</span><br><span class="line">context.rect(50,50,100,100);</span><br><span class="line">context.stroke();</span><br></pre></td></tr></table></figure><p></p><p>Note: 如果不加第二个beginPath 第二次的stroke 将使得当前路径中的两条子路径都被描边，这意味着它会重绘第一个矩形。</p><h5 id="填充路径时使用的“非零环绕规则”"><a href="#填充路径时使用的“非零环绕规则”" class="headerlink" title="填充路径时使用的“非零环绕规则”"></a>填充路径时使用的“非零环绕规则”</h5><p>如果当前路径是循环的，或是包含多个相交的子路径，那么canvas的绘图环境变量就使用“非零环绕规则”。</p><p>非零环绕规则：</p><ol><li>对给定区域画一条足够长的线段，使其线段的终点完全落在路径范围之外。</li><li>将计数器初始化为0， 然后，每当这条线段与路径上的直线或曲线相交时，就改变计数器的值。</li><li>与路径的顺时针部分相交，则+1。</li><li>与路径的逆时针部分相交，则-1。</li><li>如果计数器的最终结果不是0，那么此区域就在路径里面，在调用fill方法是，浏览器就会对其进行填充。</li></ol><h5 id="剪纸效果"><a href="#剪纸效果" class="headerlink" title="剪纸效果"></a>剪纸效果</h5><p>绘制两个园，使用顺时针绘制内部园，逆时针绘制外部圆，对其填色，产生剪纸效果。</p><p>Note：当使用arc方法向当前路径中添加子路径时，该方法必须将上一条子路径的终点与说话圆弧的起点相连。</p><p>arc方法可以控制路径的方向，而rect方法则不行。可以使用path或line代替</p><h4 id="线段"><a href="#线段" class="headerlink" title="线段"></a>线段</h4><p>方法：moveTo 和 lineTo<br>使用stroke方法绘制。</p><h4 id="线段与像素边界"><a href="#线段与像素边界" class="headerlink" title="线段与像素边界"></a>线段与像素边界</h4><ol><li>在某2个像素的边界处绘制一条1像素的线段，那么该线段实际上会占据2个像素的宽度。</li><li>如果在像素边界出绘制一条1像素的垂直线段，那么canvas的绘图环境对象会试着将半个像素在边界中线的右边，将另一半像素绘制在左边。</li></ol><h5 id="网格的绘制。"><a href="#网格的绘制。" class="headerlink" title="网格的绘制。"></a>网格的绘制。</h5><p>Note：</p><h5 id="橡皮筋式选取框"><a href="#橡皮筋式选取框" class="headerlink" title="橡皮筋式选取框"></a>橡皮筋式选取框</h5><p>example：</p><h5 id="虚线的绘制：drawDashedLine-context-context-canvas-width-context-height-20-context-canvas-height-20-14"><a href="#虚线的绘制：drawDashedLine-context-context-canvas-width-context-height-20-context-canvas-height-20-14" class="headerlink" title="虚线的绘制：drawDashedLine(context, context.canvas.width, context.height, 20, context.canvas.height-20, 14);"></a>虚线的绘制：drawDashedLine(context, context.canvas.width, context.height, 20, context.canvas.height-20, 14);</h5><h5 id="通过扩展CanvasRenderingContext2D来绘制虚线"><a href="#通过扩展CanvasRenderingContext2D来绘制虚线" class="headerlink" title="通过扩展CanvasRenderingContext2D来绘制虚线"></a>通过扩展CanvasRenderingContext2D来绘制虚线</h5><h4 id="线段与连接点的绘制"><a href="#线段与连接点的绘制" class="headerlink" title="线段与连接点的绘制"></a>线段与连接点的绘制</h4><p>lineCap 线帽：bevel|miter|round</p><h4 id="圆弧与圆形的绘制"><a href="#圆弧与圆形的绘制" class="headerlink" title="圆弧与圆形的绘制"></a>圆弧与圆形的绘制</h4><p>arc：arc(x, y, radius, startAngle, endAngle, counterClockwise)</p><p>以橡皮筋式辅助线来协助画圆：<br>example：TODO</p><h5 id="arcTo-方法"><a href="#arcTo-方法" class="headerlink" title="arcTo 方法"></a>arcTo 方法</h5><p>arcTo(x1，y1，x2，y2，radius)</p><h4 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h4><ul><li>二次贝塞尔曲线：二次曲线，两个锚点一个控制点。<br><code>quadraticCurveTo(cx, cy, ex, ey)</code> 控制点， 锚点</li><li>三次方贝塞尔曲线：<code>bezierCurveTo(double cpx, double cpy, double cp2x, double cp2y, double x, double y)</code></li></ul><h4 id="多边形的绘制"><a href="#多边形的绘制" class="headerlink" title="多边形的绘制"></a>多边形的绘制</h4><p>moveTo 和 lineTo 的结合</p><p>createPolygonPath 创建多个点的多边形</p><p>example：拖动多边形对象</p><p>编辑贝塞尔曲线：</p><h4 id="自动滚动网页，使其段落路径所对应的元素显示在窗口中"><a href="#自动滚动网页，使其段落路径所对应的元素显示在窗口中" class="headerlink" title="自动滚动网页，使其段落路径所对应的元素显示在窗口中"></a>自动滚动网页，使其段落路径所对应的元素显示在窗口中</h4><p>scrollPathIntoView：</p><h4 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h4><p>对canvas坐标系统进行移动，旋转，缩放等操作。</p><h4 id="坐标系的平移、缩放与旋转"><a href="#坐标系的平移、缩放与旋转" class="headerlink" title="坐标系的平移、缩放与旋转"></a>坐标系的平移、缩放与旋转</h4><p>rotate（double angleInRadians）<br>scale（double x， double y）<br>translate（double x， double y）</p><h5 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">drawArrow(context)</span><br><span class="line">context.translate(canvas.width, 0)</span><br><span class="line">context.scale(-1, 1)</span><br><span class="line">drawArrow(context)</span><br></pre></td></tr></table></figure><h4 id="图像合成"><a href="#图像合成" class="headerlink" title="图像合成"></a>图像合成</h4><p>在canvas中将某个物体绘制在一个物体之上，那么浏览器就会简单的把原物体的图像叠放在目标物体的图像上面。<br>globalCompositeOperation的属性改变默认的图像合成行为。</p><h4 id="剪辑区域"><a href="#剪辑区域" class="headerlink" title="剪辑区域"></a>剪辑区域</h4><p>clip</p><h5 id="通过剪辑区域来擦除图像"><a href="#通过剪辑区域来擦除图像" class="headerlink" title="通过剪辑区域来擦除图像"></a>通过剪辑区域来擦除图像</h5><p><code>clearRect(0,0,canvas.width, canvas.height)</code></p><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><p>文本对象有3个主要方法：</p><ul><li>strokeText(text, x, y)</li><li>fillText(text, x, y)</li><li>measureText(text): 返回一个名为width的属性。表示该文本所占用的宽度。</li></ul><p>canvas文本对象有3个相关属性：</p><ul><li>font</li><li>textAlign</li><li>textBaseline</li></ul><h5 id="子啊圆弧周围绘制文本"><a href="#子啊圆弧周围绘制文本" class="headerlink" title="子啊圆弧周围绘制文本"></a>子啊圆弧周围绘制文本</h5><p>步骤：</p><ul><li>计算圆弧周围每个字符的绘制坐标</li><li>将坐标系平移至绘制字符的地点</li><li>将坐标系旋转PI/2-angle度</li><li>对字符进行描边或填充操作</li></ul><p>Note： 应用程序必须先调用 translate方法后调用rotate方法。</p><h3 id="图像与视频"><a href="#图像与视频" class="headerlink" title="图像与视频"></a>图像与视频</h3><p>canvas的绘图环境提供了4个用于绘图及操作的方法：</p><ul><li>drawImage()</li><li>getImageData()</li><li>putImageData()</li><li>createImageData()</li></ul><p>drawImage 可以将另外一个canvas的内容或者视频的其中一帧绘制到当前canvas之中。</p><h4 id="在canvas中绘制图像"><a href="#在canvas中绘制图像" class="headerlink" title="在canvas中绘制图像"></a>在canvas中绘制图像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var image = new Image()</span><br><span class="line">image.src = &quot;aa&quot;</span><br><span class="line">image.onload = function()&#123;</span><br><span class="line">	context.drawImage(image, 0, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法缺点：必须等待图片加载完成之后才能进行绘制，如果尚未完成加载就进行绘制，会执行失败，而且没有任何提示。</p><p>drawImage 方法：</p><ul><li>drawImage(image, dx, dy)</li><li>drawImage(image, dx, dy, dw, dh)</li><li>drawImage(iamge, sx, sy, sw, sh, dx, dy, dw, dh)</li></ul><p>可以在canvas范围之外绘制图像：图片放大<br>按比例系数，计算图片显示位置</p><h4 id="将一个canvas绘制到另一个canvas之中。"><a href="#将一个canvas绘制到另一个canvas之中。" class="headerlink" title="将一个canvas绘制到另一个canvas之中。"></a>将一个canvas绘制到另一个canvas之中。</h4><p>使用离屏canvas，通常需要遵循4个步骤：</p><ol><li>创建用作离屏canvas的元素。</li><li>设置离屏canvas的高度和宽度。</li><li>在离屏canvas之中进行绘制。</li><li>将离屏canvas的全部或者一部分内容复制到正在显示的canvas之中。</li></ol><p>Note： 离屏canvas会占据一定的内存，不过他们可以显著的提高绘图效率。</p><h3 id="操作图像的像素"><a href="#操作图像的像素" class="headerlink" title="操作图像的像素"></a>操作图像的像素</h3><h4 id="获取图像数据"><a href="#获取图像数据" class="headerlink" title="获取图像数据"></a>获取图像数据</h4><p>getImageData() putImageData()</p><p>ImageData 对象：</p><ul><li>width：设备像素为单位的图像数据宽度。</li><li>height：设备像素为单位的图像数据高度。</li><li>data： 包含各个设备像素数值的数组。</li></ul><p>getImageData():运行的速度比较慢，每次检测到鼠标按下事件的时候，才调用一次getImageData()。</p><p>Note：putImageData()不受全局设置的影响。</p><h4 id="修改图像数据"><a href="#修改图像数据" class="headerlink" title="修改图像数据"></a>修改图像数据</h4><p>ImageData对象中的数组：data属性指向一个包含8位二进制整数的数组，这些整数的值位于0~255之间，分别表示一个像素的红、绿、蓝及透明度分量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(i=3; i&lt;imageData.data.length-4;i += 4 )&#123;</span><br><span class="line">    imageData.data[i] = imageData.data[i] / 2 // Alpha</span><br><span class="line">    imageData.data[i+1] = imageData.data[i+1] // red</span><br><span class="line">    imageData.data[i+2] = imageData.data[i+2] // green</span><br><span class="line">    imageData.data[i+3] = imageData.data[i+3] // blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="图像滤镜"><a href="#图像滤镜" class="headerlink" title="图像滤镜"></a>图像滤镜</h5><p>从255之中减去每个像素的分量值。</p><p>example：浮雕滤镜</p><h5 id="用工作线程处理图像（webworker）"><a href="#用工作线程处理图像（webworker）" class="headerlink" title="用工作线程处理图像（webworker）"></a>用工作线程处理图像（webworker）</h5><p><code>var sunglassFilter = new Worker(&quot;sunglassFilter.js&quot;)</code> 创建一个工作线程。传递给worder构造器的文件名表示工作线程将要执行的javascript文件。</p><p>将耗时的代码放在工作线程中，及时响应用户操作<br>封装算法。</p><h4 id="结合剪辑区域来绘制图像"><a href="#结合剪辑区域来绘制图像" class="headerlink" title="结合剪辑区域来绘制图像"></a>结合剪辑区域来绘制图像</h4><p>图像渐渐淡出：设置alpha值 或者设置globalAlpha</p><p>离屏canvas制作动画：</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>drawImageData 要比putImageData快</p><p>提高效率方法：</p><ol><li>避免在循环体内直接范围对象的属性， 放在局部变量中。</li><li>应该用循环计数器来遍历完整的像素，而非像素分量。</li><li>逆向遍历与移位技巧的效果并不好。</li><li>不要频繁的调用getImageData()来获取数据。</li></ol><h4 id="放大镜"><a href="#放大镜" class="headerlink" title="放大镜"></a>放大镜</h4><p>步骤：</p><ol><li>调用putImageData将上一次背景图像回复到canvas</li><li>调用getImageData捕捉当前位置image</li><li>将剪辑区域设定为放大镜所在范围</li><li>调用drawImage方法，将放大后的图像绘制到canvas中</li><li>绘制放大镜的镜片。</li></ol><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><h4 id="动画循环"><a href="#动画循环" class="headerlink" title="动画循环"></a>动画循环</h4><p>Note：不要使用<code>setInterval</code>或者<code>setTimeOut</code>来做动画。并不能提供制作动画所需要的精确计时机制。它们只是让应用程序能在某个大致时间运行而已。</p><p>不应主动命令浏览器何时去绘制下一帧动画，这应该有浏览器来通知你：使用requerstAnimationFrame</p><h5 id="通过requestAnimationFrame让浏览器自行决定帧速度。"><a href="#通过requestAnimationFrame让浏览器自行决定帧速度。" class="headerlink" title="通过requestAnimationFrame让浏览器自行决定帧速度。"></a>通过requestAnimationFrame让浏览器自行决定帧速度。</h5><p>不使用<code>setInterval</code>和<code>setTimeOut</code>方法原因：</p><ul><li>他们都是通用方法，并不是专门制作动画而用。</li><li>即使向其传递以毫秒为单位的参数值，他们也达不到毫秒级的精确性。</li><li>没有对调用动画循环的机制作优化。</li><li>不考虑绘制动画的最佳时机，而只是一味的以某个大致的时间间隔来调用动画循环。</li></ul><p>返回：传递一个时间值。</p><p>polyfill 多端支持。</p><h4 id="帧速度的计算"><a href="#帧速度的计算" class="headerlink" title="帧速度的计算"></a>帧速度的计算</h4><p>计算：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var lastTime = 0;</span><br><span class="line">function calculateFps()&#123;</span><br><span class="line">    var now = (+new Date),fps = 1000/(now - lastTime);</span><br><span class="line">    lastTime = now;</span><br><span class="line">    return fps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function animate(time)&#123;</span><br><span class="line">    eraseBackground();</span><br><span class="line">    drawBackground();</span><br><span class="line">    update();</span><br><span class="line">    draw();</span><br><span class="line"></span><br><span class="line">    context.fillStyle = &apos;cornflowerblur&apos;;</span><br><span class="line">    context.fillText(calculateFps().toFixed() + &apos; fps&apos; , 20, 60);</span><br><span class="line">    window.requestNextAnimationFrame(animate);</span><br><span class="line">&#125;</span><br><span class="line">window.requestNextAnimationFrame(animate);</span><br></pre></td></tr></table></figure><p></p><h4 id="以不同的帧速率来执行各种任务"><a href="#以不同的帧速率来执行各种任务" class="headerlink" title="以不同的帧速率来执行各种任务"></a>以不同的帧速率来执行各种任务</h4><h4 id="恢复动画背景"><a href="#恢复动画背景" class="headerlink" title="恢复动画背景"></a>恢复动画背景</h4><p>三种办法：</p><ol><li>将内容全部擦除，并重新绘制</li><li>仅重绘内容发生变化的那部分区域</li><li>从离屏缓存区中将内容发生变化的那部分背景图像复制到屏幕上。</li></ol><h5 id="利用剪辑区域来处理动画背景"><a href="#利用剪辑区域来处理动画背景" class="headerlink" title="利用剪辑区域来处理动画背景"></a>利用剪辑区域来处理动画背景</h5><p>如果背景图像很简单，可以全部擦除然后重绘。如果背景复杂，使用离屏</p><ol><li>调用context.save(), 保存canvas状态</li><li>调用beginPath开始新路径</li><li>在context对象上调用arc rect 等方法设置路径</li><li>调用context.clip 剪辑区域</li><li>擦除canvas中的图像</li><li>将背景图像绘制到屏幕canvas中（绘制操作实际上只会影响剪辑区域所在范围）</li><li>恢复canvas的状态参数，该操作主要是为了重置剪辑区域。</li></ol><h5 id="利用图块复制技术来处理动画背景"><a href="#利用图块复制技术来处理动画背景" class="headerlink" title="利用图块复制技术来处理动画背景"></a>利用图块复制技术来处理动画背景</h5><p>将整个背景一次性的复制到离屏canvas中，稍后从离屏canvas中只将修复动画背景所需的那一块图像复制到屏幕中即可。</p><p>优缺点：</p><ul><li>剪辑区域：</li><li>图块复制技术：速度快，但是占据内存</li></ul><h4 id="双缓冲技术"><a href="#双缓冲技术" class="headerlink" title="双缓冲技术"></a>双缓冲技术</h4><p>单缓冲产生闪烁：先讲东西绘制在离屏上 然后一次性的复制到canvas中。<br>双缓冲技术可以有效的消除动画闪烁，浏览器会自动采用双缓冲实现canvas元素。开发者不需要自己实现。</p><p>检测双环从技术：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function animate(now)&#123;</span><br><span class="line">    eraseBackground();</span><br><span class="line">    for(var i=0; i&lt;500000;++i)&#123;</span><br><span class="line">        sum +=i;</span><br><span class="line">    &#125;</span><br><span class="line">    drawBackground()</span><br><span class="line">    draw()</span><br><span class="line">    requestNextAnimationFrame(time)</span><br><span class="line">&#125;</span><br><span class="line">requestNextAnimationFrame(time)</span><br></pre></td></tr></table></figure><h4 id="基于时间的运动"><a href="#基于时间的运动" class="headerlink" title="基于时间的运动"></a>基于时间的运动</h4><p>使动画在所有情况下都以相同速度播放。不受帧速率的影响。<br>根据物体的速度计算出两帧之间所移动的像素数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">像素/帧 = 像素/秒 * 帧/秒</span><br></pre></td></tr></table></figure><p></p><h4 id="背景的滚动"><a href="#背景的滚动" class="headerlink" title="背景的滚动"></a>背景的滚动</h4><p>通过移动canvas绘图环境对象的原点坐标来实现背景滚动效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var SKY_VELOCITY = 30,skyOffset = 0;</span><br><span class="line">   </span><br><span class="line">   function draw()&#123;</span><br><span class="line">   	skyOffset = skyOffset &lt; canvas.width?skyOffset + SKY_VELOCITY:0;</span><br><span class="line">       context.save();</span><br><span class="line">       context.translate(-skyOffset, 0);</span><br><span class="line">       context.drawImage(sky, 0 , 0);</span><br><span class="line">       context.drawImage(sky, sky.width, 0);</span><br><span class="line">       cintext.restore();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>随着绘画环境对象原点的移动，原来位于屏幕外的那副图像渐渐的滚动到屏幕内。</p><h4 id="视差动画"><a href="#视差动画" class="headerlink" title="视差动画"></a>视差动画</h4><p>让动画图层以不同的速冻滚动，这样就实现了视差效果。</p><h4 id="用户手势"><a href="#用户手势" class="headerlink" title="用户手势"></a>用户手势</h4><p>用户通过鼠标或者手指触摸来与动画互动。</p><h4 id="定时动画"><a href="#定时动画" class="headerlink" title="定时动画"></a>定时动画</h4><h5 id="秒表"><a href="#秒表" class="headerlink" title="秒表"></a>秒表</h5><h5 id="动画计时器"><a href="#动画计时器" class="headerlink" title="动画计时器"></a>动画计时器</h5><h4 id="动画制作的最佳指导原则"><a href="#动画制作的最佳指导原则" class="headerlink" title="动画制作的最佳指导原则"></a>动画制作的最佳指导原则</h4><ul><li>使用类似requstNextAnimationFrame() 这样的polyfill 方法来保持浏览器兼容性。</li><li>将业务逻辑的更新与动画的绘制分开</li><li>使用基于时间的运动来协调动画的播放速度</li><li>用剪辑区域或者图块复制技术将复杂的背景图像恢复到屏幕上。</li><li>必要时可使用一个或多个离屏缓冲区提升背景的绘制速度</li><li>不要手工实现传动的双缓冲算法：浏览器会自动实现</li><li>不要通过css指定阴影及圆角效果</li><li>不要在canvas中进行带阴影效果的绘制操作</li><li>不要在播放动画时分配内存</li><li>使用性能调试及时间轴工具来监控并改善动画的绘制效率。</li></ul><h3 id="精灵"><a href="#精灵" class="headerlink" title="精灵"></a>精灵</h3><p>要制作一个精灵对象，必须让开发者能把他们绘制出来，能够将其放置于动画中的制定位置，并且能以给定的速度将其从一个地方移动到另一个地方。这些精灵或许还能接受调用者的命令，来执行某些特定的动作。</p><p>精灵对象有两个方法：paint 和 update<br>构造器：精灵名称，绘制器及行为数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var Sprite = function(name, painter, behaviors)&#123;</span><br><span class="line">    if (name !== undefined) this.name = name;</span><br><span class="line">    if (painter !== undefined) this.painter = painter;</span><br><span class="line">    this.top = 0;</span><br><span class="line">    this.left = 0;</span><br><span class="line">    this.width = 10;</span><br><span class="line">    this.height = 10;</span><br><span class="line">    this.velocityX = 0;</span><br><span class="line">    this.velocityY = 0;</span><br><span class="line">    this.visible = true;</span><br><span class="line">    this.animation = false;</span><br><span class="line">    this.behaviors = behaviors || &#123;&#125;;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sprite.prototype = &#123;</span><br><span class="line">	paint : function(context)&#123;</span><br><span class="line">    	if(this.painter !== undefined &amp;&amp; this.visible)&#123;</span><br><span class="line">        	this.painter.paint(this, context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    update: function(context, time)&#123;</span><br><span class="line">        for(var i=0;i&lt;this.behaviors.length;++i)&#123;</span><br><span class="line">            this.behaviors[i].execute(this, context, time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="精灵绘制器"><a href="#精灵绘制器" class="headerlink" title="精灵绘制器"></a>精灵绘制器</h4><p>Sprite 对象与绘制其内容的绘制器对象之间是解耦的。在程序运行时动态的设定绘制器。<br>Painter对象可被归纳为三类：</p><ul><li>描边及填充绘制器<br>会调用stroke 与 fill 在内的canvas图形函数来绘制精灵。<br>享元模式：使用一个对象表示多个概念</li><li><p>图像绘制器</p></li><li><p>精灵表绘制器<br>为了节省磁盘空间，减少下载次数，如果制作动画的精灵对象其没帧所用的图像都比较小，那么可以把他们放在一张图片中。<br>精灵表会把精灵表中表示当前动画帧的那个单元格画出来。调用advance方法可以将索引值加1.</p></li></ul><h4 id="精灵对象的行为"><a href="#精灵对象的行为" class="headerlink" title="精灵对象的行为"></a>精灵对象的行为</h4><p>只要实现execute(sprite, context, time)方法的对象，都可以叫做 行为。该方法一般会以某种方式来修改精灵的属性，比如移动其位置，或是修改其外观。</p><p>精灵含有一个行为对象数组，它的update方法会遍历该数组，使每个行为对象都得以执行一次。</p><h4 id="将多个行为组合起来"><a href="#将多个行为组合起来" class="headerlink" title="将多个行为组合起来"></a>将多个行为组合起来</h4><p>精灵含有一个行为对象数组，所以开发者可以根据需要向任何精灵对象之中添加任意数量的行为对象。精灵的update方法会从数组中的第一个行为对象开始，一直遍历到最后一个对象，依次调用其execute方法。</p><p>精灵可以有任意多的行为对象，开发者可以在程序运行时直接操作behaviors数组来增加及移除行为对象。</p><h4 id="限时触发的行为"><a href="#限时触发的行为" class="headerlink" title="限时触发的行为"></a>限时触发的行为</h4><p>该对象所封装的行为只会在给定的事件段内表现出来。</p><h4 id="精灵动画制作器"><a href="#精灵动画制作器" class="headerlink" title="精灵动画制作器"></a>精灵动画制作器</h4><h3 id="移动平台开发"><a href="#移动平台开发" class="headerlink" title="移动平台开发"></a>移动平台开发</h3><p>移动设备开发技巧</p><ul><li>通过指定名为<code>viewport</code>的<code>metatag</code> 我们可以根据特定的设备与显示方向优化应用程序的视窗大小。</li><li>css媒体查询</li><li>以javascript语言编写监听器，检测媒体特征的变更。</li><li>处理触摸事件。</li><li>禁用惯性滚动功能。</li><li>禁止用户缩放应用程序，停用“DIV闪烁”等特征</li><li>实现手指缩放功能。</li><li>在平板电脑上实现基于canvas的虚拟键盘控件。</li></ul><p>在ios是那个运行</p><ul><li>创建应用程序图标及启动图像</li><li>使用媒体特征查询技术来选择适当的应用程序图标及启动图像</li><li>令html5应用程序直接以全屏模式运行，不显示任何浏览器饰件</li><li>设置状态栏的背景色</li></ul></div><p class="readmore"><a href="/2016/06/21/html5 Canvas/">阅读更多</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/06/21/Events/">cEvents</a></h2><div class="post-meta">2016-06-21</div><div class="post-content"><h3 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>一个对象可以通过这个模块，向另一个对象传递消息</p><p>任意对象都可以发布指定事件，被<code>EventEmitter</code>实例的 <code>on</code> 方法监听到。</p></div><p class="readmore"><a href="/2016/06/21/Events/">阅读更多</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/06/21/Buffer/">Buffer</a></h2><div class="post-meta">2016-06-21</div><div class="post-content"><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Buffer对象时node用来处理二进制数据的一个接口。<br>javascript比较擅长处理Unicode数据。<br>Buffer就是为了解决这个问题的。</p><p>Node原生提供的全局对象。可以直接用，不需要<code>require</code></p><p>Buffer与字符串的互相转换，需要指定编码格式。</p><ul><li>ascii</li><li>utf8</li><li>utf16le</li><li>ucs2 utf16le的别名</li><li>base64</li><li>hex 将每个字节转为两个十六进制字符</li></ul><p>V8引擎将Buffer对象占用的内存，解释为一个整数数组，而不是二进制数组。</p><h4 id="Buffer构造函数"><a href="#Buffer构造函数" class="headerlink" title="Buffer构造函数"></a>Buffer构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 参数时整数，指定分配多少个字节内存</span><br><span class="line">var hello = new Buffer(5)</span><br><span class="line"></span><br><span class="line">// 参数是数组，数组成员必须是整数值</span><br><span class="line">var hello = new Buffer([0x48, 0x65,0x6c,0x6c, 0x6f])</span><br><span class="line">hello.toString() // Hello</span><br><span class="line"></span><br><span class="line">// 参数是字符串</span><br><span class="line">var hello = new Buffer(&apos;Hello&apos;)</span><br><span class="line">var hello = new Buffer(&apos;Hello&apos;, &apos;utf8&apos;)</span><br><span class="line"></span><br><span class="line">// 参数是一个buffer 拷贝</span><br><span class="line">var hello2 = new Buffer(hello)</span><br></pre></td></tr></table></figure><h4 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h4><ul><li>Buffer.isEncoding(‘utf8’) 返回一个布尔值</li><li>Buffer.isBuffer() 是否为一个buffer实例</li><li>Buffer.byteLength(string, ‘utf8’) 返回字符串实际占据的字节长度。</li><li>Buffer.concat(［arr］, length) 将一组Buffer对象合并为一个Buffer对象</li></ul><h4 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h4><ul><li>length</li><li>write(string, start[0])</li><li>slice() 指定位置切割</li><li>toString()</li><li>toJSON() 如果JSON.stringfy 方法调用 Buffer 实例，默认会调用toJSON方法</li></ul></div><p class="readmore"><a href="/2016/06/21/Buffer/">阅读更多</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/06/21/数据库管理/">数据库管理</a></h2><div class="post-meta">2016-06-21</div><div class="post-content"><h2 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h2><h3 id="第一章-数据库系统概述"><a href="#第一章-数据库系统概述" class="headerlink" title="第一章 数据库系统概述"></a>第一章 数据库系统概述</h3><p><strong>数据模型：</strong> 隐藏许多低级存储细节的高级数据描述结构的集合。<br><strong>模式：</strong> 基于数据模型的数据描述。</p><p><strong>三级抽象模式：</strong></p><p>1.概念模式。以数据模型的形式描述存储的数据。<br>2.2.物理模式。描述概念模式中关系在磁盘等存储设备上实际是如何存储的。<br>3.3.外模式。允许位单个用户和用户组定制数据存取。</p><h4 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h4><p>加锁协议：每一个事务需要遵守的规则集合，以确保即使有几个事务在交叉工作，但它们所产生的结果等同于所有事务按照某种串行顺序执行的结果。</p><p>共享锁：可以由两个不同事务同时获取。<br>互斥锁：没有其他事务能够获得该对象上的任何锁。</p><h3 id="第二章-实体联系模型"><a href="#第二章-实体联系模型" class="headerlink" title="第二章 实体联系模型"></a>第二章 实体联系模型</h3><p>实体ER：允许我们利用对象和它们之间的联系去描述现实企业的数据。</p><h4 id="数据库设计与ER图"><a href="#数据库设计与ER图" class="headerlink" title="数据库设计与ER图"></a>数据库设计与ER图</h4><ol><li>数据分析<br>1.哪些数据需要存储<br>2.哪些操作是最频繁的<br>3.哪些性能要求<br>4.。。。</li><li>概念数据库设计<br>1.在需求分析中得到的数据信息，用来为存储在数据库中的数据开发一个高级描述。<br>2.通常使用ER模型或类似的高级数据模型来完成。</li><li>逻辑数据库设计<br>1.讲ER模型转换为关系数据库模式。</li></ol><h4 id="实体，属性和实体集"><a href="#实体，属性和实体集" class="headerlink" title="实体，属性和实体集"></a>实体，属性和实体集</h4><h3 id="第三章-关系模型"><a href="#第三章-关系模型" class="headerlink" title="第三章 关系模型"></a>第三章 关系模型</h3><p>数据库由一个或多个关系组成，每个关系是行和列组成的表。</p><p>1 关系模式：对表的每个列进行描述<br>2 关系实例：表</p><h4 id="码约束"><a href="#码约束" class="headerlink" title="码约束"></a>码约束</h4><p>候选码：能够唯一确定每条纪录的关系的字段集合称为关系的候选码。<br>主码（primary key）：<br>外码：</p><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>可以看成一个关系表，但是其中的纪录没有直接存储在数据库中，而是在需要的时候根据视图定义计算出来的。</p><h3 id="第四章-关系代数与演算"><a href="#第四章-关系代数与演算" class="headerlink" title="第四章 关系代数与演算"></a>第四章 关系代数与演算</h3><h4 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h4><ol><li>并</li><li>交</li><li>差</li><li>叉积</li></ol><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><h5 id="条件连接（）"><a href="#条件连接（）" class="headerlink" title="条件连接（）"></a>条件连接（）</h5><h5 id="相等连接"><a href="#相等连接" class="headerlink" title="相等连接"></a>相等连接</h5><h5 id="自然连接：-R和S所有同名字段都相等"><a href="#自然连接：-R和S所有同名字段都相等" class="headerlink" title="自然连接： R和S所有同名字段都相等"></a>自然连接： R和S所有同名字段都相等</h5><h4 id="除"><a href="#除" class="headerlink" title="除"></a>除</h4><h3 id="第五章-SQL：查询，约束与触发器"><a href="#第五章-SQL：查询，约束与触发器" class="headerlink" title="第五章 SQL：查询，约束与触发器"></a>第五章 SQL：查询，约束与触发器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select [distinct] select-list</span><br><span class="line">from from-list</span><br><span class="line">where qualification</span><br></pre></td></tr></table></figure><h4 id="select-命令中的表达式和字符串"><a href="#select-命令中的表达式和字符串" class="headerlink" title="select 命令中的表达式和字符串"></a>select 命令中的表达式和字符串</h4><p>字符串比较：</p><p>= &gt; &lt; 等 按照字母顺序进行。<br>like 操作通配符 ％（0个或多个）， _(一个任意字符)</p><h4 id="union-intersect-except"><a href="#union-intersect-except" class="headerlink" title="union, intersect, except"></a>union, intersect, except</h4><p>union: 默认去掉重复，为了保留重复 使用 union all m＋n<br>intersect：保留重复， min(m,n)<br>except：保留重复 m-n</p><h4 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h4><h4 id="聚集操作符"><a href="#聚集操作符" class="headerlink" title="聚集操作符"></a>聚集操作符</h4><ol><li>count</li><li>sum</li><li>avg</li><li>max</li><li>min</li></ol><p>在sql中如果select 子句中使用聚集操作，那么就只能使用聚集操作符，除非参加查询包含 group by 子句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select s.name, s.age</span><br><span class="line">from student s</span><br><span class="line">where s.age = (</span><br><span class="line">			select MAX(s2.age) from student s2</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h4 id="group-by-and-having"><a href="#group-by-and-having" class="headerlink" title="group by and having"></a>group by and having</h4><p>having: 规定分组的条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select [distinct] select_list</span><br><span class="line">from from-list</span><br><span class="line">where qualification</span><br><span class="line">group by grouping-list</span><br><span class="line">having group-qualification</span><br></pre></td></tr></table></figure><h4 id="触发器和主动数据库"><a href="#触发器和主动数据库" class="headerlink" title="触发器和主动数据库"></a>触发器和主动数据库</h4><p>触发器是一个过程，它对数据库的特定改变进行响应。</p><p>一个触发器包含三个部分：</p><ol><li>事件。激活触发器的数据库改变</li><li>条件。当触发器激活时运行的查询或检测</li><li>动作。当触发器被激活并且条件为真时，DBMS要执行的动作。</li></ol><h3 id="存储与索引概述"><a href="#存储与索引概述" class="headerlink" title="存储与索引概述"></a>存储与索引概述</h3><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>在磁盘上组织数据纪录的一种数据结构，用于优化某类数据检索的操作。</p><p>数据项：代替存储在索引文件中的纪录</p><p>3种不同的数据项存储：</p><ol><li>数据项k*是一个真正的数据纪录</li><li>数据项是一个<code>&lt;k,rid&gt;</code>对，其中rid是搜索码值为k的数据纪录的纪录id</li><li>数据项是一个<code>&lt;k,rid-list&gt;</code>对，其中rid-list是搜索码值为k的数据纪录的纪录id的列表</li></ol><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>数据纪录的顺序与某一索引的数据顺序相同或类似，称为聚簇索引，否则，为非聚簇索引。</p><p>实际上，数据更新时维护数据的顺序性代价很高，所以文件很少是保持有序的。</p><h4 id="主索引与次索引"><a href="#主索引与次索引" class="headerlink" title="主索引与次索引"></a>主索引与次索引</h4><p>建立在包含主码的字段集合上的索引称为主索引<br>其他的索引称为次索引</p><p>如果我们知道一个索引没有重复，那么就可以知道其搜索码包含候选码，我们称这样的索引为惟一索引。</p><h4 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h4><p>基于哈希的索引</p><p>纪录被放在不同的捅中，其中一个桶由一个主页构成，或者由一个主页和多个页构成的链组成。<br>一个纪录属于哪个桶由一个特殊的函数用于搜索码来决定，这个函数成为哈希函数。<br>给出一个桶号，允许我们进行一到两次磁盘i／o就能检索出该桶的主页</p><p>基于树的索引</p><p>使用树型的数据结构</p><p>树的最下层，叶子层 包含数据项。<br>所有搜索开始于最顶端的节点－跟节点。<br>所有非叶子节点都讲搜索定位到正确的叶子节点中。</p></div><p class="readmore"><a href="/2016/06/21/数据库管理/">阅读更多</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/06/21/cookie和session/">cookie 和 session</a></h2><div class="post-meta">2016-06-21</div><div class="post-content"><p>[TOC]</p><h2 id="cookie-和-session"><a href="#cookie-和-session" class="headerlink" title="cookie 和 session"></a>cookie 和 session</h2><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>1.服务器向客户端发送cookie。http协议 <code>set-cookie</code><br>2.浏览器将cookie保存<br>3.每次浏览器都会将cokie发向服务器。</p><p>cookie参数<br>1.path：表示cookie影响到的路径，匹配该路径才发送这个cookie<br>2.expries和maxAge：过期时间，多久后过期<br>3.secure：为true时 在http中无效，只有在https中有效<br>4.httpOnly：不允许脚本操作document.cookie去更改cookie</p><p>弊端：<br>1.数据保存在客户端，很容易被篡改<br>2.每次客户端都向服务端发送cookie</p><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>session的数据保留在服务器端</p><p>通过一个<code>session_id</code>来进行。<br>session_id通常存放在客户端的cookie中。</p><p>session 可以存放在<br>1.内存、<br>2.cookie本身、<br>3.redis 或 memcached 等缓存中，<br>4.数据库中</p><h3 id="signedCookie"><a href="#signedCookie" class="headerlink" title="signedCookie"></a>signedCookie</h3></div><p class="readmore"><a href="/2016/06/21/cookie和session/">阅读更多</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/06/13/hello-world/">Hello World</a></h2><div class="post-meta">2016-06-13</div><div class="post-content"><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p></div><p class="readmore"><a href="/2016/06/13/hello-world/">阅读更多</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/04/22/css权威指南/">CSS 权威指南</a></h2><div class="post-meta">2016-04-22</div><div class="post-content"><h3 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS 选择器"></a>CSS 选择器</h3><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a><em>分组</em></h4><ul><li>使用<code>，</code>号来分割，定义一个规则，右边的样式，将应用到左边的所有元素。</li><li>通过分组，可以将某些类型压缩在一起。这样可以得到一个更简洁的样式表。</li></ul><h5 id="通配符选择器。"><a href="#通配符选择器。" class="headerlink" title="通配符选择器。*"></a>通配符选择器。<code>*</code></h5><ul><li>应用到所有元素。</li></ul><h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a><em>类选择器</em></h4><p>要应用样式而不考虑具体是哪些元素，通常使用类选择器。</p><h4 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a><em>ID选择器</em></h4><p><code>#id</code> 唯一性。</p><h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a><em>属性选择器</em></h4><p><code>href</code>，<code>title</code>…</p><ul><li>可以多个属性链接在一起使用。</li><li>同时可以使用属性值进行精确选择。</li></ul><h5 id="子串匹配属性选择器"><a href="#子串匹配属性选择器" class="headerlink" title="子串匹配属性选择器"></a>子串匹配属性选择器</h5><ul><li><code>~=value</code> 值中包含<code>value</code>单词的属性。</li><li><code>^=value</code> 值中以<code>value</code>开始的属性。</li><li><code>$=value</code> 值中以<code>value</code>结尾的属性。</li><li><code>*=value</code> 值中包含<code>value</code>的属性。</li><li><code>|=value</code> 匹配语言值，如<code>[src|=&quot;img&quot;] ==&gt; img-1.png</code>。</li><li>parent &gt; children 匹配子元素。</li><li><code>+</code> 匹配相邻兄弟元素。</li></ul><h5 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h5><p><em>静态伪类</em></p><ul><li><code>：link</code>，<code>：visited</code><br><em>动态伪类</em></li><li><code>：focus</code>，<code>：hover</code>，<code>：active</code></li></ul><h5 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h5><p>*<code>：first-child</code>：第一个子元素的元素。</p><h5 id="结合伪类"><a href="#结合伪类" class="headerlink" title="结合伪类"></a>结合伪类</h5><p>可以在同一个选择器中结合使用伪类，顺序指定不重要。</p><h3 id="值和单位"><a href="#值和单位" class="headerlink" title="值和单位"></a>值和单位</h3><h4 id="em和ex"><a href="#em和ex" class="headerlink" title="em和ex"></a>em和ex</h4><ul><li>em：当前元素字体大小*em值。</li><li>ex：相对于字符<code>X</code>的高度，通常为字符的一半。<h4 id="deg-角度值，解释0-360度范围内的度数，可以是负值。"><a href="#deg-角度值，解释0-360度范围内的度数，可以是负值。" class="headerlink" title="deg 角度值，解释0~360度范围内的度数，可以是负值。"></a>deg 角度值，解释0~360度范围内的度数，可以是负值。</h4></li></ul><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>字体的显示依赖于客户端，如果没有定义的字体，将使用客户端默认的字体样式。</p><h4 id="字体系列"><a href="#字体系列" class="headerlink" title="字体系列"></a>字体系列</h4><p><em>Serif字体</em></p><ul><li>字体成比例，而且上下有短线。如果字体字符根据其大小不同有不同的宽度，称为是成比例的。</li></ul><p><em>Sans-serif</em></p><ul><li>字体成比例，而且上下没有短线。</li></ul><p><em>Monospace</em></p><ul><li>字体不成比例的，通常用于模拟打印机打出的字体。，字体宽度完全相同。</li></ul><p><em>Cursive</em></p><ul><li>模仿人的手写字体。主要由曲线和serif字体中没有笔画的字体组成。</li></ul><p><em>Fantasy</em></p><ul><li>这些字体无法用任何特性来表示。只有一点是确认的，就是无法用任意之中类型归类该字体样式。</li><li><code>font-family:value</code> value有特殊字符，或者有空格，多个单词，使用引号。</li><li>通用字体系列，如果加了引号，浏览器会认为是一种名为该通用字体名的字体。</li></ul><h4 id="font-weight"><a href="#font-weight" class="headerlink" title="font-weight"></a>font-weight</h4><ul><li>100~900 取值范围。</li><li>normal 为400。，bolder 为700。</li><li>lighter，bolder。</li></ul><h4 id="font-style"><a href="#font-style" class="headerlink" title="font-style"></a>font-style</h4><p>明确<code>italic</code>和<code>oblique</code>文本之间的差别。</p><ul><li><code>italic</code>：意大利体。</li><li><code>oblique</code>：简单的字体倾斜。</li><li><code>normal</code>：</li><li><code>inherit</code>：</li></ul><h4 id="font-variant"><a href="#font-variant" class="headerlink" title="font-variant"></a>font-variant</h4><p>小型大写字母不是一般的大写字母，是采用不同大小的字母。</p><h4 id="font-stretch"><a href="#font-stretch" class="headerlink" title="font-stretch"></a>font-stretch</h4><ul><li><code>wider</code>：比父元素字体更宽。</li></ul><h3 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h3><h4 id="text-indent-缩进。"><a href="#text-indent-缩进。" class="headerlink" title="text-indent 缩进。"></a>text-indent 缩进。</h4><p><em>作用于块级元素，无法使用到行内元素，不会改变当前盒子宽度。</em></p><ul><li>百分比：相对于当前块。</li><li>length：具体数值。</li></ul><h4 id="text-align"><a href="#text-align" class="headerlink" title="text-align"></a>text-align</h4><p><em>justify：两端对齐，字符宽度由用户浏览器和其他因素决定。如<code>letter-space</code>等。</em></p><h4 id="line-height"><a href="#line-height" class="headerlink" title="line-height"></a>line-height</h4><p><em>最基本的情况是可以增加或减少文本行之间的垂直间隔。</em></p><ul><li>定义文本线之间的最小距离，而不是一个绝对值。文本线拉开的距离可能比line-height值更大。</li><li>并不影响替换元素的布局，当时确实可以引用到替换元素中。<br><em>待整理</em></li></ul><h4 id="间隔和对齐"><a href="#间隔和对齐" class="headerlink" title="间隔和对齐"></a>间隔和对齐</h4><p><em>letter-spacing</em><br><em>word-spacing</em></p><h4 id="文本转换"><a href="#文本转换" class="headerlink" title="文本转换"></a>文本转换</h4><p><em>text-transform</em></p><ul><li>uppercase 转换为大写。</li><li>lowercase 转换为小写。</li><li>capitalize 每个首字母大写。</li><li>默认值为none，不做任何改动。</li></ul><h4 id="文本装饰"><a href="#文本装饰" class="headerlink" title="文本装饰"></a>文本装饰</h4><p><code>text-decoration</code></p><ul><li><code>underline</code> 下划线。</li><li><code>overline</code> 顶端划线。</li><li><code>line-through</code> 中划线。</li><li><code>blink</code> 文本闪烁。</li></ul><h4 id="文本阴影"><a href="#文本阴影" class="headerlink" title="文本阴影"></a>文本阴影</h4><p><code>text-shadow</code></p><ul><li>第一个值定义阴影的颜色，第二个，第三个值定义阴影的偏移距离，第四个值定义了阴影的模糊半径。</li></ul><h4 id="处理空白符"><a href="#处理空白符" class="headerlink" title="处理空白符"></a>处理空白符</h4><p><em>white-space</em></p><ul><li>会影响用户代理对资源文档中的空格，换行和tab字符的处理。</li><li><code>normal</code>：默认情况下浏览器已经完成了空白处理：把所有的空格合并为一个空格处理。</li><li><code>pre</code>：空白符不会被忽略。</li><li><code>nowrap</code>：不能换行，除非出现<code>br</code>。</li><li><code>pre-wrap</code>：文本保留空白，但是文本会正常的换行。</li><li><code>pre-line</code>：与<code>pre-wrap</code>相反，文本会合并空白符，但保留换行。</li></ul><h4 id="文本方向"><a href="#文本方向" class="headerlink" title="文本方向"></a>文本方向</h4><p><em>direction</em></p><ul><li><code>ltr</code></li><li><code>rtl</code></li></ul><h3 id="基本视觉格式化"><a href="#基本视觉格式化" class="headerlink" title="基本视觉格式化"></a>基本视觉格式化</h3><h4 id="基本框"><a href="#基本框" class="headerlink" title="基本框"></a>基本框</h4><p>CSS假定每个元素都会生成一个或多个矩形框，这称为元素框。各个元素框中心有一个内容去（content area）。这个内容区有可选的内边距，边框，外边距。<br><em>边框与内容和内边距有相同的背景。边框不能为负</em></p><h4 id="使用auto"><a href="#使用auto" class="headerlink" title="使用auto"></a>使用auto</h4><ul><li>marging-left，margin-right和width 的值可以设为<code>auto</code>。</li><li>当其中两个设置为固定值，另外一个设为<code>auto</code>，auto值的宽度会被自动拉伸到夫容器。</li><li>当三个都使用固定长度，并且总和小于父容器时，margin-right会被force to be the rest of the length。</li><li>当width设置成为<code>auto</code>时，<code>margin-left：auto； margin-right：100px；</code>margin-left会被设置成0；</li></ul><h5 id="负外边距"><a href="#负外边距" class="headerlink" title="负外边距"></a>负外边距</h5><ul><li>当水平元素过分受限时，有一个规则，要求重置右外边距。这也会得到一个负值。</li><li>只有外边距能小于0；</li></ul><h4 id="替换元素"><a href="#替换元素" class="headerlink" title="替换元素"></a>替换元素</h4><ul><li>width为<code>auto</code>时，实际宽度为img的宽度。</li><li>如果一个替换元素的width 不同于自身的宽度，那么它的高度也会成比例变化。反过来也一样。</li></ul><h4 id="垂直格式化"><a href="#垂直格式化" class="headerlink" title="垂直格式化"></a>垂直格式化</h4><p><em>一个元素的默认高度右其内容决定。高度会随其内容的变化而相应改变。</em></p><ul><li>如果元素的高度设置小于内容的高度，会产生滚动条。<code>overflow</code>属性设置滚动条。</li><li>如果margin-top和margin-bottom都设置成为<code>auto</code>，那么他们会被强制设置成为0。也就无法实现垂直居中。但对于定位元素来说将有所不同。</li></ul><h5 id="百分数高度"><a href="#百分数高度" class="headerlink" title="百分数高度"></a>百分数高度</h5><p><em>元素设置高度为百分数，为针对父元素的高度的百分比。</em></p><ul><li>如果包裹元素height设置为<code>auto</code>，那么它将于内部元素高度相同。</li></ul><h5 id="合并垂直外边距"><a href="#合并垂直外边距" class="headerlink" title="合并垂直外边距"></a>合并垂直外边距</h5><p><em>两个外边距中教小的会被较大的合并。元素的内边距和边框绝对不会合并。</em></p><h5 id="负外边距-1"><a href="#负外边距-1" class="headerlink" title="负外边距"></a>负外边距</h5><p><em>负外边距导致元素重叠</em><br><em>元素后出现可能会覆盖较早出现的元素</em><br><em>note：包裹元素width设置成<code>auto</code>，内部负外边距，同样对父元素同级的兄弟元素位置产生影响。</em></p><h4 id="内联元素"><a href="#内联元素" class="headerlink" title="内联元素"></a>内联元素</h4><p>img也是内联元素，只不过是替换元素。</p><h5 id="行布局"><a href="#行布局" class="headerlink" title="行布局"></a>行布局</h5><hr><h6 id="增加框属性"><a href="#增加框属性" class="headerlink" title="增加框属性"></a>增加框属性</h6><p><em>使用padding可以增加内联元素的框的距离，但不影响行高。</em></p><ul><li>替换元素可以增加行高，但不影响<code>line-height</code>。</li><li>如果没有line-height值，vertical-align百分比数值就会失效。</li><li>为行内替换元素增加border，margin和padding会增加行的高度。</li></ul><h5 id="替换元素与基线"><a href="#替换元素与基线" class="headerlink" title="替换元素与基线"></a>替换元素与基线</h5><ul><li>替换元素默认下行内距的底端与父元素的基线对齐。</li></ul><h4 id="改变元素的现实-display"><a href="#改变元素的现实-display" class="headerlink" title="改变元素的现实 display"></a>改变元素的现实 display</h4><p><em>run-in</em>：将元素定义为run-in框，后面跟着块元素，便会有嵌入后一个元素的效果。并且根据原树等级继承属性。</p><h3 id="内边距，边框，外边距"><a href="#内边距，边框，外边距" class="headerlink" title="内边距，边框，外边距"></a>内边距，边框，外边距</h3><h4 id="基本元素框"><a href="#基本元素框" class="headerlink" title="基本元素框"></a>基本元素框</h4><p><em>所有文档元素都生成一个矩形框，称为元素框（element box），它描述一个元素在文本布局中所占用的空间大小。因此，每个框影响着其他元素框的位置和大小。</em></p><h4 id="宽度和高度"><a href="#宽度和高度" class="headerlink" title="宽度和高度"></a>宽度和高度</h4><p><em>不能应用到行内非替换元素中。</em></p><h4 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h4><p><em>百分比使用父元素的宽度的百分比。</em></p><h3 id="浮动和定位"><a href="#浮动和定位" class="headerlink" title="浮动和定位"></a>浮动和定位</h3><h4 id="浮动元素"><a href="#浮动元素" class="headerlink" title="浮动元素"></a>浮动元素</h4><ul><li>会以某种方式将元素从文档的正常流中删除，不过它还是会影响布局。</li><li>这种影响来源于一个现象：一个元素浮动起来，其他元素会<code>环绕</code>该元素。</li><li>浮动元素外边距不会合并。</li></ul><h4 id="不浮动"><a href="#不浮动" class="headerlink" title="不浮动"></a>不浮动</h4><p><code>float:none</code></p><h4 id="浮动的详细内幕"><a href="#浮动的详细内幕" class="headerlink" title="浮动的详细内幕"></a>浮动的详细内幕</h4><ul><li><code>containning block</code>：浮动元素的保含块就是其最近的祖先元素。</li><li>浮动元素会生成一个快级框，而不论它本身元素是什么。</li><li>浮动元素规则：1.浮动元素外边距不能超越包含框的内边距。2.浮动元素外边距不会覆盖，从合。3-5：不能比之前浮动元素的顶端高。7.如果没有足够的空间，元素会被挤到下一行。</li></ul><h4 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h4><p><code>clear</code>确保元素不会出现在浮动元素中。</p><ul><li>会增加元素的上外边距，使之出现在浮动元素的下方。</li></ul></div><p class="readmore"><a href="/2016/04/22/css权威指南/">阅读更多</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/04/21/flex/">Flex</a></h2><div class="post-meta">2016-04-21</div><div class="post-content"><h2 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h2><p>浏览器支持性：ie10+, 其他主流浏览器</p><p>可以简便，完整，响应式的实现各种布局</p><p>Flexible box 弹性布局</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">    display:-webkit-flex;</span><br><span class="line">    display:flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>行内元素也可以使用Flex布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">    display:inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Notes: 元素设置flex之后，<code>float</code> <code>clear</code> <code>vertical-align</code></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Flex容器（flex container）<br>Flex项目（flex item）</p><p>容器默认存在两根轴：</p><pre><code>- x轴（main axis）： main start  -- main end</div><p class="readmore"><a href="/2016/04/21/flex/">阅读更多</a></p></div><div class="post"><h2 class="post-title"><a href="/2015/02/19/git/">git</a></h2><div class="post-meta">2015-02-19</div><div class="post-content"><h2 id="git-命令笔记"><a href="#git-命令笔记" class="headerlink" title="git 命令笔记"></a>git 命令笔记</h2><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ul><li>git clone</li><li>git add</li><li>git status</li><li>git commit</li><li>git remote</li><li>git fetch</li><li>git pull</li><li>git push</li></ul><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="$ git clone"></a>$ git clone</h3><p><code>$ git clone &lt;仓库网址&gt; &lt;本地目录名&gt;</code></p><h3 id="git-add"><a href="#git-add" class="headerlink" title="$ git add"></a>$ git add</h3><p><code>git add &lt;file&gt;</code></p><h3 id="git-status"><a href="#git-status" class="headerlink" title="$ git status"></a>$ git status</h3><p>查看文件修改状态</p><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="$ git commit"></a>$ git commit</h3><h4 id="git-commit-–amend"><a href="#git-commit-–amend" class="headerlink" title="$ git commit –amend"></a>$ git commit –amend</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &apos;initial commit&apos;</span><br><span class="line">$ git add forgotten_file</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><p>上面操作只会产生一次提交<br>第二次 add 的文件会添加到commit中。</p><h4 id="取消已经暂存的文件"><a href="#取消已经暂存的文件" class="headerlink" title="取消已经暂存的文件"></a>取消已经暂存的文件</h4><p>不小心git add了不想提交的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD benchmarks.rb</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       benchmarks.rb</span><br></pre></td></tr></table></figure><h4 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h4><p>如果觉得一个文件没有必要修改 想回复到之前版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- benchmarks.rb</span><br></pre></td></tr></table></figure><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p><code>$ git rm test.txt</code></p><p>恢复：</p><p><code>$ git checkout -- test.txt</code></p><h3 id="远程仓库-git-remote"><a href="#远程仓库-git-remote" class="headerlink" title="远程仓库  git remote"></a>远程仓库 git remote</h3><p><code>$ git remote add origin git@github.com:michaelliao/learngit.git</code></p><p>添加后 远程仓库的名字就是 <code>origin</code> 也可以改成别的东西</p><h3 id="远程仓库回滚"><a href="#远程仓库回滚" class="headerlink" title="远程仓库回滚"></a>远程仓库回滚</h3><p>假设你有3个commit如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">commit 3</span><br><span class="line">commit 2</span><br><span class="line">commit 1</span><br></pre></td></tr></table></figure><p>其中最后一次提交commit 3是错误的，那么可以执行：</p><p><code>git reset --hard HEAD~1</code></p><p>会发现，HEAD is now at commit 2。</p><p>然后再使用git push –force将本次变更强行推送至服务器。这样在服务器上的最后一次错误提交也彻底消失了。</p><p><strong>Note：</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">值得注意的是，这类操作比较比较危险，例如：在你的commit 3之后别人又提交了新的commit 4，那在你强制推送之后，那位仁兄的commit 4也跟着一起消失了。</span><br></pre></td></tr></table></figure><p></p></div><p class="readmore"><a href="/2015/02/19/git/">阅读更多</a></p></div><nav class="page-navigator"><a class="extend prev" rel="prev" href="/page/3/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span></nav></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/DOM/">DOM</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/DOM/html/">html</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/canvas/">canvas</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/css/html/">html</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/html/">html</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/html/css/">css</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/node-js/">node.js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/仓库管理/">仓库管理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端框架/">前端框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/外语/">外语</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/微信/">微信</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/支付/">支付</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/仓库管理/" style="font-size: 15px;">仓库管理</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/DOM/" style="font-size: 15px;">DOM</a> <a href="/tags/html/" style="font-size: 15px;">html</a> <a href="/tags/Vue/" style="font-size: 15px;">Vue</a> <a href="/tags/MVVM/" style="font-size: 15px;">MVVM</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/canvas/" style="font-size: 15px;">canvas</a> <a href="/tags/收集/" style="font-size: 15px;">收集</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/开发工具/" style="font-size: 15px;">开发工具</a> <a href="/tags/node-js/" style="font-size: 15px;">node.js</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/sql/" style="font-size: 15px;">sql</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/webGL/" style="font-size: 15px;">webGL</a> <a href="/tags/微信/" style="font-size: 15px;">微信</a> <a href="/tags/原型工具/" style="font-size: 15px;">原型工具</a> <a href="/tags/微信支付/" style="font-size: 15px;">微信支付</a> <a href="/tags/事务/" style="font-size: 15px;">事务</a> <a href="/tags/设计/" style="font-size: 15px;">设计</a> <a href="/tags/外语/" style="font-size: 15px;">外语</a> <a href="/tags/英语/" style="font-size: 15px;">英语</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/10/26/设计工作流/">设计工作流</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/14/Vue2/">Vue2</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/13/grid/">CSS Grid</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/26/DOM-Enlightenment-2013-2/">DOM.Enlightenment.2013.2</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/06/canvas资料收集/">canvas资料收集</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/06/原型工具/">原型工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/22/React-Router/">React Router</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/09/微信接口归纳/">微信接口归纳</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/05/权限系统/">权限系统</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/03/oAuth/">oAuth</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">马达的笔记.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>